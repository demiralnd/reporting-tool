import {
  require_exceljs_min
} from "./chunk-3X2IETT4.js";
import {
  require_dayjs_min,
  require_lodash
} from "./chunk-DRENFLML.js";
import {
  require_react
} from "./chunk-2KTPFGKL.js";
import {
  __commonJS,
  __require
} from "./chunk-HM4MQYWN.js";

// node_modules/@corbe30/fortune-excel/dist/icons/ExportIcon.js
var require_ExportIcon = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/icons/ExportIcon.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    function ExportIcon() {
      return react_1.default.createElement(
        "svg",
        { width: "24", height: "24", fill: "none" },
        react_1.default.createElement("path", { d: "M12 14L11.6464 14.3536L12 14.7071L12.3536 14.3536L12 14ZM12.5 5C12.5 4.72386 12.2761 4.5 12 4.5C11.7239 4.5 11.5 4.72386 11.5 5L12.5 5ZM6.64645 9.35355L11.6464 14.3536L12.3536 13.6464L7.35355 8.64645L6.64645 9.35355ZM12.3536 14.3536L17.3536 9.35355L16.6464 8.64645L11.6464 13.6464L12.3536 14.3536ZM12.5 14L12.5 5L11.5 5L11.5 14L12.5 14Z", fill: "#525C6F", strokeWidth: "0.35", stroke: "#525C6F" }),
        react_1.default.createElement("path", { d: "M5 16L5 17C5 18.1046 5.89543 19 7 19L17 19C18.1046 19 19 18.1046 19 17V16", stroke: "#525C6F", strokeWidth: "1.25" })
      );
    }
    exports.default = ExportIcon;
  }
});

// node_modules/@corbe30/fortune-excel/dist/icons/ImportIcon.js
var require_ImportIcon = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/icons/ImportIcon.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    function ImportIcon() {
      return react_1.default.createElement(
        "svg",
        { width: "24", height: "24", fill: "none" },
        react_1.default.createElement("path", { d: "M12 5L11.6464 4.64645L12 4.29289L12.3536 4.64645L12 5ZM12.5 14C12.5 14.2761 12.2761 14.5 12 14.5C11.7239 14.5 11.5 14.2761 11.5 14L12.5 14ZM6.64645 9.64645L11.6464 4.64645L12.3536 5.35355L7.35355 10.3536L6.64645 9.64645ZM12.3536 4.64645L17.3536 9.64645L16.6464 10.3536L11.6464 5.35355L12.3536 4.64645ZM12.5 5L12.5 14L11.5 14L11.5 5L12.5 5Z", fill: "#525C6F", stroke: "#525C6F", strokeWidth: "0.35" }),
        react_1.default.createElement("path", { d: "M5 16L5 17C5 18.1046 5.89543 19 7 19L17 19C18.1046 19 19 18.1046 19 17V16", stroke: "#525C6F", strokeWidth: "1.25" })
      );
    }
    exports.default = ImportIcon;
  }
});

// node_modules/@corbe30/fortune-excel/dist/common/constant.js
var require_constant = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/common/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ALIGNMENT_DEFAULT = exports.DATA_VERIFICATION_TYPE2_MAP = exports.COMMON_TYPE2 = exports.OPERATOR_MAP = exports.DATA_VERIFICATION_REV_MAP = exports.DATA_VERIFICATION_MAP = exports.fontFamilys = exports.numFmtDefaultMap = exports.borderTypes = exports.OEM_CHARSET = exports.indexedColors = exports.numFmtDefault = exports.BuiltInCellStyles = exports.ST_CellType = exports.workbookRels = exports.theme1File = exports.worksheetFilePath = exports.sharedStringsFile = exports.stylesFile = exports.calcChainFile = exports.workBookFile = exports.contentTypesFile = exports.appFile = exports.coreFile = exports.columeHeader_word_index = exports.columeHeader_word = void 0;
    exports.columeHeader_word = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    exports.columeHeader_word_index = {
      A: 0,
      B: 1,
      C: 2,
      D: 3,
      E: 4,
      F: 5,
      G: 6,
      H: 7,
      I: 8,
      J: 9,
      K: 10,
      L: 11,
      M: 12,
      N: 13,
      O: 14,
      P: 15,
      Q: 16,
      R: 17,
      S: 18,
      T: 19,
      U: 20,
      V: 21,
      W: 22,
      X: 23,
      Y: 24,
      Z: 25
    };
    exports.coreFile = "docProps/core.xml";
    exports.appFile = "docProps/app.xml";
    exports.contentTypesFile = "[Content_Types].xml";
    exports.workBookFile = "xl/workbook.xml";
    exports.calcChainFile = "xl/calcChain.xml";
    exports.stylesFile = "xl/styles.xml";
    exports.sharedStringsFile = "xl/sharedStrings.xml";
    exports.worksheetFilePath = "xl/worksheets/";
    exports.theme1File = "xl/theme/theme1.xml";
    exports.workbookRels = "xl/_rels/workbook.xml.rels";
    exports.ST_CellType = {
      Boolean: "b",
      Date: "d",
      Error: "e",
      InlineString: "inlineStr",
      Number: "n",
      SharedString: "s",
      String: "str"
    };
    exports.BuiltInCellStyles = {
      "0": "Normal"
    };
    exports.numFmtDefault = {
      "0": "General",
      "1": "0",
      "2": "0.00",
      "3": "#,##0",
      "4": "#,##0.00",
      "9": "0%",
      "10": "0.00%",
      "11": "0.00E+00",
      "12": "# ?/?",
      "13": "# ??/??",
      "14": "m/d/yy",
      "15": "d-mmm-yy",
      "16": "d-mmm",
      "17": "mmm-yy",
      "18": "h:mm AM/PM",
      "19": "h:mm:ss AM/PM",
      "20": "h:mm",
      "21": "h:mm:ss",
      "22": "m/d/yy h:mm",
      "37": "#,##0 ;(#,##0)",
      "38": "#,##0 ;[Red](#,##0)",
      "39": "#,##0.00;(#,##0.00)",
      "40": "#,##0.00;[Red](#,##0.00)",
      "45": "mm:ss",
      "46": "[h]:mm:ss",
      "47": "mmss.0",
      "48": "##0.0E+0",
      "49": "@"
    };
    exports.indexedColors = {
      "0": "00000000",
      "1": "00FFFFFF",
      "2": "00FF0000",
      "3": "0000FF00",
      "4": "000000FF",
      "5": "00FFFF00",
      "6": "00FF00FF",
      "7": "0000FFFF",
      "8": "00000000",
      "9": "00FFFFFF",
      "10": "00FF0000",
      "11": "0000FF00",
      "12": "000000FF",
      "13": "00FFFF00",
      "14": "00FF00FF",
      "15": "0000FFFF",
      "16": "00800000",
      "17": "00008000",
      "18": "00000080",
      "19": "00808000",
      "20": "00800080",
      "21": "00008080",
      "22": "00C0C0C0",
      "23": "00808080",
      "24": "009999FF",
      "25": "00993366",
      "26": "00FFFFCC",
      "27": "00CCFFFF",
      "28": "00660066",
      "29": "00FF8080",
      "30": "000066CC",
      "31": "00CCCCFF",
      "32": "00000080",
      "33": "00FF00FF",
      "34": "00FFFF00",
      "35": "0000FFFF",
      "36": "00800080",
      "37": "00800000",
      "38": "00008080",
      "39": "000000FF",
      "40": "0000CCFF",
      "41": "00CCFFFF",
      "42": "00CCFFCC",
      "43": "00FFFF99",
      "44": "0099CCFF",
      "45": "00FF99CC",
      "46": "00CC99FF",
      "47": "00FFCC99",
      "48": "003366FF",
      "49": "0033CCCC",
      "50": "0099CC00",
      "51": "00FFCC00",
      "52": "00FF9900",
      "53": "00FF6600",
      "54": "00666699",
      "55": "00969696",
      "56": "00003366",
      "57": "00339966",
      "58": "00003300",
      "59": "00333300",
      "60": "00993300",
      "61": "00993366",
      "62": "00333399",
      "63": "00333333",
      "64": null,
      //system Foreground n/a
      "65": null
      //system Background n/a
    };
    exports.OEM_CHARSET = {
      "0": "ANSI_CHARSET",
      "1": "DEFAULT_CHARSET",
      "2": "SYMBOL_CHARSET",
      "77": "MAC_CHARSET",
      "128": "SHIFTJIS_CHARSET",
      "129": "HANGUL_CHARSET",
      "130": "JOHAB_CHARSET",
      "134": "GB2312_CHARSET",
      "136": "CHINESEBIG5_CHARSET",
      "161": "GREEK_CHARSET",
      "162": "TURKISH_CHARSET",
      "163": "VIETNAMESE_CHARSET",
      "177": "HEBREW_CHARSET",
      "178": "ARABIC_CHARSET",
      "186": "BALTIC_CHARSET",
      "204": "RUSSIAN_CHARSET",
      "222": "THAI_CHARSET",
      "238": "EASTEUROPE_CHARSET",
      "255": "OEM_CHARSET"
    };
    exports.borderTypes = {
      none: 0,
      thin: 1,
      hair: 2,
      dotted: 3,
      dashed: 4,
      dashDot: 5,
      dashDotDot: 6,
      double: 7,
      medium: 8,
      mediumDashed: 9,
      mediumDashDot: 10,
      mediumDashDotDot: 11,
      slantDashDot: 12,
      thick: 13
    };
    exports.numFmtDefaultMap = {
      "yyyy/m/d;@": "yyyy/MM/dd",
      "yyyy&quot;年&quot;m&quot;月&quot;d&quot;日&quot;;@": "yyyy&quot;年&quot;MM&quot;月&quot;dd&quot;日&quot;",
      "[$-409]yyyy/m/d\\ h:mm\\ AM/PM;@": "yyyy/MM/dd hh:mm AM/PM"
    };
    exports.fontFamilys = {
      "0": "defualt",
      "1": "Roman",
      "2": "Swiss",
      "3": "Modern",
      "4": "Script",
      "5": "Decorative"
    };
    exports.DATA_VERIFICATION_MAP = {
      list: "dropdown",
      whole: "number_integer",
      decimal: "number_decimal",
      custom: "text_content",
      textLength: "text_length",
      date: "date",
      unknown1: "number",
      // no match yet
      unknown2: "checkbox",
      // no match yet
      unknown3: "validity"
      // no match yet
    };
    exports.DATA_VERIFICATION_REV_MAP = {
      dropdown: "list",
      number: "decimal",
      number_integer: "decimal",
      number_decimal: "decimal",
      text_length: "textLength",
      date: "date"
    };
    exports.OPERATOR_MAP = {
      between: "between",
      notBetween: "notBetween",
      equal: "equal",
      notEqualTo: "notEqual",
      moreThanThe: "greaterThan",
      lessThan: "lessThan",
      greaterOrEqualTo: "greaterThanOrEqual",
      lessThanOrEqualTo: "lessThanOrEqual"
    };
    exports.COMMON_TYPE2 = [
      "number",
      "number_integer",
      "number_decimal",
      "text_length"
    ];
    exports.DATA_VERIFICATION_TYPE2_MAP = {
      common: {
        between: "bw",
        notBetween: "nb",
        equal: "eq",
        notEqualTo: "ne",
        moreThanThe: "gt",
        lessThan: "lt",
        greaterOrEqualTo: "gte",
        lessThanOrEqualTo: "lte"
      },
      text_content: {
        include: "include",
        exclude: "exclude",
        equal: "equal"
      },
      date: {
        between: "bw",
        notBetween: "nb",
        equal: "eq",
        notEqualTo: "ne",
        earlierThan: "bf",
        noEarlierThan: "nbf",
        laterThan: "af",
        noLaterThan: "naf"
      },
      validity: {
        card: "card",
        phone: "phone"
      }
    };
    exports.ALIGNMENT_DEFAULT = -1;
  }
});

// node_modules/@corbe30/fortune-excel/dist/common/method.js
var require_method = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/common/method.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rgb2hex = exports.getObjType = exports.setMerge = exports.getMultiFormulaValue = exports.getPeelOffX14 = exports.getTransR1C1ToSequence = exports.getSingleSequenceToNum = exports.getSqrefRawArrFormat = exports.getRegionSequence = exports.getMultiSequenceToNum = exports.isContainMultiType = exports.isKoera = exports.isJapanese = exports.isChinese = exports.fromulaRef = exports.escapeCharacter = exports.generateRandomIndex = exports.LightenDarkenColor = exports.getRowHeightPixel = exports.getColumnWidthPixel = exports.getXmlAttibute = exports.getPxByEMUs = exports.getptToPxRatioByDPI = exports.getcellrange = exports.getRangetxt = void 0;
    var constant_1 = require_constant();
    function getRangetxt(range, sheettxt) {
      var row0 = range["row"][0], row1 = range["row"][1];
      var column0 = range["column"][0], column1 = range["column"][1];
      if (row0 == null && row1 == null) {
        return sheettxt + chatatABC(column0) + ":" + chatatABC(column1);
      } else if (column0 == null && column1 == null) {
        return sheettxt + (row0 + 1) + ":" + (row1 + 1);
      } else {
        if (column0 == column1 && row0 == row1) {
          return sheettxt + chatatABC(column0) + (row0 + 1);
        } else {
          return sheettxt + chatatABC(column0) + (row0 + 1) + ":" + chatatABC(column1) + (row1 + 1);
        }
      }
    }
    exports.getRangetxt = getRangetxt;
    function getcellrange(txt, sheets, sheetId) {
      if (sheets === void 0) {
        sheets = {};
      }
      if (sheetId === void 0) {
        sheetId = "1";
      }
      var val = txt.split("!");
      var sheettxt = "", rangetxt = "", sheetIndex = -1;
      if (val.length > 1) {
        sheettxt = val[0];
        rangetxt = val[1];
        var si = sheets[sheettxt];
        if (si == null) {
          sheetIndex = parseInt(sheetId);
        } else {
          sheetIndex = parseInt(si);
        }
      } else {
        sheetIndex = parseInt(sheetId);
        rangetxt = val[0];
      }
      if (rangetxt.indexOf(":") == -1) {
        var row = parseInt(rangetxt.replace(/[^0-9]/g, "")) - 1;
        var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));
        if (!isNaN(row) && !isNaN(col)) {
          return {
            row: [row, row],
            column: [col, col],
            sheetIndex
          };
        } else {
          return null;
        }
      } else {
        var rangetxtArray = rangetxt.split(":");
        var row = [], col = [];
        row[0] = parseInt(rangetxtArray[0].replace(/[^0-9]/g, "")) - 1;
        row[1] = parseInt(rangetxtArray[1].replace(/[^0-9]/g, "")) - 1;
        if (row[0] > row[1]) {
          return null;
        }
        col[0] = ABCatNum(rangetxtArray[0].replace(/[^A-Za-z]/g, ""));
        col[1] = ABCatNum(rangetxtArray[1].replace(/[^A-Za-z]/g, ""));
        if (col[0] > col[1]) {
          return null;
        }
        return {
          row,
          column: col,
          sheetIndex
        };
      }
    }
    exports.getcellrange = getcellrange;
    function ABCatNum(abc) {
      abc = abc.toUpperCase();
      var abc_len = abc.length;
      if (abc_len == 0) {
        return NaN;
      }
      var abc_array = abc.split("");
      var wordlen = constant_1.columeHeader_word.length;
      var ret = 0;
      for (var i = abc_len - 1; i >= 0; i--) {
        if (i == abc_len - 1) {
          ret += constant_1.columeHeader_word_index[abc_array[i]];
        } else {
          ret += Math.pow(wordlen, abc_len - i - 1) * (constant_1.columeHeader_word_index[abc_array[i]] + 1);
        }
      }
      return ret;
    }
    function chatatABC(index) {
      var wordlen = constant_1.columeHeader_word.length;
      if (index < wordlen) {
        return constant_1.columeHeader_word[index];
      } else {
        var last = 0, pre = 0, ret = "";
        var i = 1, n = 0;
        while (index >= wordlen / (wordlen - 1) * (Math.pow(wordlen, i++) - 1)) {
          n = i;
        }
        var index_ab = index - wordlen / (wordlen - 1) * (Math.pow(wordlen, n - 1) - 1);
        last = index_ab + 1;
        for (var x = n; x > 0; x--) {
          var last1 = last, x1 = x;
          if (x == 1) {
            last1 = last1 % wordlen;
            if (last1 == 0) {
              last1 = 26;
            }
            return ret + constant_1.columeHeader_word[last1 - 1];
          }
          last1 = Math.ceil(last1 / Math.pow(wordlen, x - 1));
          ret += constant_1.columeHeader_word[last1 - 1];
          if (x > 1) {
            last = last - (last1 - 1) * wordlen;
          }
        }
      }
    }
    function getptToPxRatioByDPI() {
      return 72 / 96;
    }
    exports.getptToPxRatioByDPI = getptToPxRatioByDPI;
    function getPxByEMUs(emus) {
      if (emus == null) {
        return 0;
      }
      var inch = emus / 914400;
      var pt = inch * 72;
      var px = pt / getptToPxRatioByDPI();
      return px;
    }
    exports.getPxByEMUs = getPxByEMUs;
    function getXmlAttibute(dom, attr, d) {
      var value = dom[attr];
      value = value == null ? d : value;
      return value;
    }
    exports.getXmlAttibute = getXmlAttibute;
    function getColumnWidthPixel(columnWidth) {
      var pix = Math.round((columnWidth - 0.83) * 8 + 5);
      return pix;
    }
    exports.getColumnWidthPixel = getColumnWidthPixel;
    function getRowHeightPixel(rowHeight) {
      var pix = Math.round(rowHeight / getptToPxRatioByDPI());
      return pix;
    }
    exports.getRowHeightPixel = getRowHeightPixel;
    function LightenDarkenColor(sixColor, tint) {
      var hex = sixColor.substring(sixColor.length - 6, sixColor.length);
      var rgbArray = hexToRgbArray("#" + hex);
      var hslArray = rgbToHsl(rgbArray[0], rgbArray[1], rgbArray[2]);
      if (tint > 0) {
        hslArray[2] = hslArray[2] * (1 - tint) + tint;
      } else if (tint < 0) {
        hslArray[2] = hslArray[2] * (1 + tint);
      } else {
        return "#" + hex;
      }
      var newRgbArray = hslToRgb(hslArray[0], hslArray[1], hslArray[2]);
      return rgbToHex("RGB(" + newRgbArray.join(",") + ")");
    }
    exports.LightenDarkenColor = LightenDarkenColor;
    function rgbToHex(rgb) {
      var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      if (/^(rgb|RGB)/.test(rgb)) {
        var aColor = rgb.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
        var strHex = "#";
        for (var i = 0; i < aColor.length; i++) {
          var hex = Number(aColor[i]).toString(16);
          if (hex.length < 2) {
            hex = "0" + hex;
          }
          strHex += hex;
        }
        if (strHex.length !== 7) {
          strHex = rgb;
        }
        return strHex;
      } else if (reg.test(rgb)) {
        var aNum = rgb.replace(/#/, "").split("");
        if (aNum.length === 6) {
          return rgb;
        } else if (aNum.length === 3) {
          var numHex = "#";
          for (var i = 0; i < aNum.length; i += 1) {
            numHex += aNum[i] + aNum[i];
          }
          return numHex;
        }
      }
      return rgb;
    }
    function hexToRgbArray(hex) {
      var sColor = hex.toLowerCase();
      var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      if (sColor && reg.test(sColor)) {
        if (sColor.length === 4) {
          var sColorNew = "#";
          for (var i = 1; i < 4; i += 1) {
            sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
          }
          sColor = sColorNew;
        }
        var sColorChange = [];
        for (var i = 1; i < 7; i += 2) {
          sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
        }
        return sColorChange;
      }
      return null;
    }
    function hslToRgb(h, s, l) {
      var r, g, b;
      if (s == 0) {
        r = g = b = l;
      } else {
        var hue2rgb = function hue2rgb2(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    function rgbToHsl(r, g, b) {
      r /= 255, g /= 255, b /= 255;
      var max = Math.max(r, g, b), min = Math.min(r, g, b);
      var h, s, l = (max + min) / 2;
      if (max == min) {
        h = s = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return [h, s, l];
    }
    function generateRandomIndex(prefix) {
      if (prefix == null) {
        prefix = "Sheet";
      }
      var userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
      var mid = "";
      for (var i = 0; i < 5; i++) {
        mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
      }
      var time = (/* @__PURE__ */ new Date()).getTime();
      return prefix + "_" + mid + "_" + time;
    }
    exports.generateRandomIndex = generateRandomIndex;
    function escapeCharacter(str) {
      if (str == null || str.length == 0) {
        return str;
      }
      return str.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&nbsp;/g, " ").replace(/&apos;/g, "'").replace(/&iexcl;/g, "¡").replace(/&cent;/g, "¢").replace(/&pound;/g, "£").replace(/&curren;/g, "¤").replace(/&yen;/g, "¥").replace(/&brvbar;/g, "¦").replace(/&sect;/g, "§").replace(/&uml;/g, "¨").replace(/&copy;/g, "©").replace(/&ordf;/g, "ª").replace(/&laquo;/g, "«").replace(/&not;/g, "¬").replace(/&shy;/g, "­").replace(/&reg;/g, "®").replace(/&macr;/g, "¯").replace(/&deg;/g, "°").replace(/&plusmn;/g, "±").replace(/&sup2;/g, "²").replace(/&sup3;/g, "³").replace(/&acute;/g, "´").replace(/&micro;/g, "µ").replace(/&para;/g, "¶").replace(/&middot;/g, "·").replace(/&cedil;/g, "¸").replace(/&sup1;/g, "¹").replace(/&ordm;/g, "º").replace(/&raquo;/g, "»").replace(/&frac14;/g, "¼").replace(/&frac12;/g, "½").replace(/&frac34;/g, "¾").replace(/&iquest;/g, "¿").replace(/&times;/g, "×").replace(/&divide;/g, "÷").replace(/&Agrave;/g, "À").replace(/&Aacute;/g, "Á").replace(/&Acirc;/g, "Â").replace(/&Atilde;/g, "Ã").replace(/&Auml;/g, "Ä").replace(/&Aring;/g, "Å").replace(/&AElig;/g, "Æ").replace(/&Ccedil;/g, "Ç").replace(/&Egrave;/g, "È").replace(/&Eacute;/g, "É").replace(/&Ecirc;/g, "Ê").replace(/&Euml;/g, "Ë").replace(/&Igrave;/g, "Ì").replace(/&Iacute;/g, "Í").replace(/&Icirc;/g, "Î").replace(/&Iuml;/g, "Ï").replace(/&ETH;/g, "Ð").replace(/&Ntilde;/g, "Ñ").replace(/&Ograve;/g, "Ò").replace(/&Oacute;/g, "Ó").replace(/&Ocirc;/g, "Ô").replace(/&Otilde;/g, "Õ").replace(/&Ouml;/g, "Ö").replace(/&Oslash;/g, "Ø").replace(/&Ugrave;/g, "Ù").replace(/&Uacute;/g, "Ú").replace(/&Ucirc;/g, "Û").replace(/&Uuml;/g, "Ü").replace(/&Yacute;/g, "Ý").replace(/&THORN;/g, "Þ").replace(/&szlig;/g, "ß").replace(/&agrave;/g, "à").replace(/&aacute;/g, "á").replace(/&acirc;/g, "â").replace(/&atilde;/g, "ã").replace(/&auml;/g, "ä").replace(/&aring;/g, "å").replace(/&aelig;/g, "æ").replace(/&ccedil;/g, "ç").replace(/&egrave;/g, "è").replace(/&eacute;/g, "é").replace(/&ecirc;/g, "ê").replace(/&euml;/g, "ë").replace(/&igrave;/g, "ì").replace(/&iacute;/g, "í").replace(/&icirc;/g, "î").replace(/&iuml;/g, "ï").replace(/&eth;/g, "ð").replace(/&ntilde;/g, "ñ").replace(/&ograve;/g, "ò").replace(/&oacute;/g, "ó").replace(/&ocirc;/g, "ô").replace(/&otilde;/g, "õ").replace(/&ouml;/g, "ö").replace(/&oslash;/g, "ø").replace(/&ugrave;/g, "ù").replace(/&uacute;/g, "ú").replace(/&ucirc;/g, "û").replace(/&uuml;/g, "ü").replace(/&yacute;/g, "ý").replace(/&thorn;/g, "þ").replace(/&yuml;/g, "ÿ");
    }
    exports.escapeCharacter = escapeCharacter;
    var fromulaRef = (
      /** @class */
      function() {
        function fromulaRef2() {
        }
        fromulaRef2.trim = function(str) {
          if (str == null) {
            str = "";
          }
          return str.replace(/(^\s*)|(\s*$)/g, "");
        };
        fromulaRef2.functionCopy = function(txt, mode, step) {
          var _this = this;
          if (_this.operatorjson == null) {
            var arr = _this.operator.split("|"), op = {};
            for (var i_1 = 0; i_1 < arr.length; i_1++) {
              op[arr[i_1].toString()] = 1;
            }
            _this.operatorjson = op;
          }
          if (mode == null) {
            mode = "down";
          }
          if (step == null) {
            step = 1;
          }
          if (txt.substr(0, 1) == "=") {
            txt = txt.substr(1);
          }
          var funcstack = txt.split("");
          var i = 0, str = "", function_str = "", ispassby = true;
          var matchConfig = {
            bracket: 0,
            comma: 0,
            squote: 0,
            dquote: 0
          };
          while (i < funcstack.length) {
            var s = funcstack[i];
            if (s == "(" && matchConfig.dquote == 0) {
              matchConfig.bracket += 1;
              if (str.length > 0) {
                function_str += str + "(";
              } else {
                function_str += "(";
              }
              str = "";
            } else if (s == ")" && matchConfig.dquote == 0) {
              matchConfig.bracket -= 1;
              function_str += _this.functionCopy(str, mode, step) + ")";
              str = "";
            } else if (s == '"' && matchConfig.squote == 0) {
              if (matchConfig.dquote > 0) {
                function_str += str + '"';
                matchConfig.dquote -= 1;
                str = "";
              } else {
                matchConfig.dquote += 1;
                str += '"';
              }
            } else if (s == "," && matchConfig.dquote == 0) {
              function_str += _this.functionCopy(str, mode, step) + ",";
              str = "";
            } else if (s == "&" && matchConfig.dquote == 0) {
              if (str.length > 0) {
                function_str += _this.functionCopy(str, mode, step) + "&";
                str = "";
              } else {
                function_str += "&";
              }
            } else if (s in _this.operatorjson && matchConfig.dquote == 0) {
              var s_next = "";
              if (i + 1 < funcstack.length) {
                s_next = funcstack[i + 1];
              }
              var p = i - 1, s_pre = null;
              if (p >= 0) {
                do {
                  s_pre = funcstack[p--];
                } while (p >= 0 && s_pre == " ");
              }
              if (s + s_next in _this.operatorjson) {
                if (str.length > 0) {
                  function_str += _this.functionCopy(str, mode, step) + s + s_next;
                  str = "";
                } else {
                  function_str += s + s_next;
                }
                i++;
              } else if (!/[^0-9]/.test(s_next) && s == "-" && (s_pre == "(" || s_pre == null || s_pre == "," || s_pre == " " || s_pre in _this.operatorjson)) {
                str += s;
              } else {
                if (str.length > 0) {
                  function_str += _this.functionCopy(str, mode, step) + s;
                  str = "";
                } else {
                  function_str += s;
                }
              }
            } else {
              str += s;
            }
            if (i == funcstack.length - 1) {
              if (_this.iscelldata(_this.trim(str))) {
                if (mode == "down") {
                  function_str += _this.downparam(_this.trim(str), step);
                } else if (mode == "up") {
                  function_str += _this.upparam(_this.trim(str), step);
                } else if (mode == "left") {
                  function_str += _this.leftparam(_this.trim(str), step);
                } else if (mode == "right") {
                  function_str += _this.rightparam(_this.trim(str), step);
                }
              } else {
                function_str += _this.trim(str);
              }
            }
            i++;
          }
          return function_str;
        };
        fromulaRef2.downparam = function(txt, step) {
          return this.updateparam("d", txt, step);
        };
        fromulaRef2.upparam = function(txt, step) {
          return this.updateparam("u", txt, step);
        };
        fromulaRef2.leftparam = function(txt, step) {
          return this.updateparam("l", txt, step);
        };
        fromulaRef2.rightparam = function(txt, step) {
          return this.updateparam("r", txt, step);
        };
        fromulaRef2.updateparam = function(orient, txt, step) {
          var _this = this;
          var val = txt.split("!"), rangetxt, prefix = "";
          if (val.length > 1) {
            rangetxt = val[1];
            prefix = val[0] + "!";
          } else {
            rangetxt = val[0];
          }
          if (rangetxt.indexOf(":") == -1) {
            var row = parseInt(rangetxt.replace(/[^0-9]/g, ""));
            var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));
            var freezonFuc = _this.isfreezonFuc(rangetxt);
            var $row = freezonFuc[0] ? "$" : "", $col = freezonFuc[1] ? "$" : "";
            if (orient == "u" && !freezonFuc[0]) {
              row -= step;
            } else if (orient == "r" && !freezonFuc[1]) {
              col += step;
            } else if (orient == "l" && !freezonFuc[1]) {
              col -= step;
            } else if (!freezonFuc[0]) {
              row += step;
            }
            if (row < 0 || col < 0) {
              return _this.error.r;
            }
            if (!isNaN(row) && !isNaN(col)) {
              return prefix + $col + chatatABC(col) + $row + row;
            } else if (!isNaN(row)) {
              return prefix + $row + row;
            } else if (!isNaN(col)) {
              return prefix + $col + chatatABC(col);
            } else {
              return txt;
            }
          } else {
            rangetxt = rangetxt.split(":");
            var row = [], col = [];
            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, ""));
            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, ""));
            if (row[0] > row[1]) {
              return txt;
            }
            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, ""));
            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, ""));
            if (col[0] > col[1]) {
              return txt;
            }
            var freezonFuc0 = _this.isfreezonFuc(rangetxt[0]);
            var freezonFuc1 = _this.isfreezonFuc(rangetxt[1]);
            var $row0 = freezonFuc0[0] ? "$" : "", $col0 = freezonFuc0[1] ? "$" : "";
            var $row1 = freezonFuc1[0] ? "$" : "", $col1 = freezonFuc1[1] ? "$" : "";
            if (orient == "u") {
              if (!freezonFuc0[0]) {
                row[0] -= step;
              }
              if (!freezonFuc1[0]) {
                row[1] -= step;
              }
            } else if (orient == "r") {
              if (!freezonFuc0[1]) {
                col[0] += step;
              }
              if (!freezonFuc1[1]) {
                col[1] += step;
              }
            } else if (orient == "l") {
              if (!freezonFuc0[1]) {
                col[0] -= step;
              }
              if (!freezonFuc1[1]) {
                col[1] -= step;
              }
            } else {
              if (!freezonFuc0[0]) {
                row[0] += step;
              }
              if (!freezonFuc1[0]) {
                row[1] += step;
              }
            }
            if (row[0] < 0 || col[0] < 0) {
              return _this.error.r;
            }
            if (isNaN(col[0]) && isNaN(col[1])) {
              return prefix + $row0 + row[0] + ":" + $row1 + row[1];
            } else if (isNaN(row[0]) && isNaN(row[1])) {
              return prefix + $col0 + chatatABC(col[0]) + ":" + $col1 + chatatABC(col[1]);
            } else {
              return prefix + $col0 + chatatABC(col[0]) + $row0 + row[0] + ":" + $col1 + chatatABC(col[1]) + $row1 + row[1];
            }
          }
        };
        fromulaRef2.iscelldata = function(txt) {
          var val = txt.split("!"), rangetxt;
          if (val.length > 1) {
            rangetxt = val[1];
          } else {
            rangetxt = val[0];
          }
          var reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g;
          var reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g;
          if (rangetxt.indexOf(":") == -1) {
            var row = parseInt(rangetxt.replace(/[^0-9]/g, "")) - 1;
            var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));
            if (!isNaN(row) && !isNaN(col) && rangetxt.toString().match(reg_cell)) {
              return true;
            } else if (!isNaN(row)) {
              return false;
            } else if (!isNaN(col)) {
              return false;
            } else {
              return false;
            }
          } else {
            reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;
            rangetxt = rangetxt.split(":");
            var row = [], col = [];
            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, "")) - 1;
            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, "")) - 1;
            if (row[0] > row[1]) {
              return false;
            }
            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, ""));
            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, ""));
            if (col[0] > col[1]) {
              return false;
            }
            if (rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)) {
              return true;
            } else {
              return false;
            }
          }
        };
        fromulaRef2.isfreezonFuc = function(txt) {
          var row = txt.replace(/[^0-9]/g, "");
          var col = txt.replace(/[^A-Za-z]/g, "");
          var row$ = txt.substr(txt.indexOf(row) - 1, 1);
          var col$ = txt.substr(txt.indexOf(col) - 1, 1);
          var ret = [false, false];
          if (row$ == "$") {
            ret[0] = true;
          }
          if (col$ == "$") {
            ret[1] = true;
          }
          return ret;
        };
        fromulaRef2.operator = "==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^";
        fromulaRef2.error = {
          v: "#VALUE!",
          //错误的参数或运算符
          n: "#NAME?",
          //公式名称错误
          na: "#N/A",
          //函数或公式中没有可用数值
          r: "#REF!",
          //删除了由其他公式引用的单元格
          d: "#DIV/0!",
          //除数是0或空单元格
          nm: "#NUM!",
          //当公式或函数中某个数字有问题时
          nl: "#NULL!",
          //交叉运算符（空格）使用不正确
          sp: "#SPILL!"
          //数组范围有其它值
        };
        fromulaRef2.operatorjson = null;
        return fromulaRef2;
      }()
    );
    exports.fromulaRef = fromulaRef;
    function isChinese(temp) {
      var re = /[^\u4e00-\u9fa5]/;
      var reg = /[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/;
      if (reg.test(temp))
        return true;
      if (re.test(temp))
        return false;
      return true;
    }
    exports.isChinese = isChinese;
    function isJapanese(temp) {
      var re = /[^\u0800-\u4e00]/;
      if (re.test(temp))
        return false;
      return true;
    }
    exports.isJapanese = isJapanese;
    function isKoera(chr) {
      if (chr > 12592 && chr < 12687 || chr >= 44032 && chr <= 55203) {
        return true;
      }
      return false;
    }
    exports.isKoera = isKoera;
    function isContainMultiType(str) {
      var isUnicode = false;
      if (escape(str).indexOf("%u") > -1) {
        isUnicode = true;
      }
      var isNot = false;
      var reg = /[0-9a-z]/gi;
      if (reg.test(str)) {
        isNot = true;
      }
      var reEnSign = /[\x00-\xff]+/g;
      if (reEnSign.test(str)) {
        isNot = true;
      }
      if (isUnicode && isNot) {
        return true;
      }
      return false;
    }
    exports.isContainMultiType = isContainMultiType;
    function getMultiSequenceToNum(sqref) {
      if (!sqref || (sqref === null || sqref === void 0 ? void 0 : sqref.length) <= 0)
        return [];
      sqref = sqref.toUpperCase();
      var sqrefRawArr = sqref.split(" ");
      var sqrefArr = sqrefRawArr.filter(function(e) {
        return e && e.trim();
      });
      var sqrefLastArr = getSqrefRawArrFormat(sqrefArr);
      var resArr = [];
      for (var i = 0; i < sqrefLastArr.length; i++) {
        var _res = getSingleSequenceToNum(sqrefLastArr[i]);
        if (_res)
          resArr.push(_res);
      }
      return resArr;
    }
    exports.getMultiSequenceToNum = getMultiSequenceToNum;
    function getRegionSequence(arr) {
      var _a, _b;
      var formatArr = [];
      var regEn = new RegExp(/[A-Z]+|[0-9]+/g);
      var startArr = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.match(regEn);
      var lastArr = (_b = arr[1]) === null || _b === void 0 ? void 0 : _b.match(regEn);
      var columnMax = Math.max.apply(Math, [ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);
      var columnMin = Math.min.apply(Math, [ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);
      var rowMax = Math.max.apply(Math, [parseInt(startArr[1]), parseInt(lastArr[1])]);
      var rowMin = Math.min.apply(Math, [parseInt(startArr[1]), parseInt(lastArr[1])]);
      for (var i = columnMin; i <= columnMax; i++) {
        for (var j = rowMin; j <= rowMax; j++) {
          formatArr.push("".concat(chatatABC(i)).concat(j));
        }
      }
      return formatArr;
    }
    exports.getRegionSequence = getRegionSequence;
    function getSqrefRawArrFormat(arr) {
      arr === null || arr === void 0 ? void 0 : arr.map(function(el) {
        if (el.includes(":")) {
          var tempArr = el.split(":");
          if ((tempArr === null || tempArr === void 0 ? void 0 : tempArr.length) === 2) {
            arr = arr.concat(getRegionSequence(tempArr));
            arr.splice(arr.indexOf(el), 1);
          }
        }
      });
      var resultArr = arr.filter(function(value, index, array) {
        return array.indexOf(value) === index;
      });
      return resultArr;
    }
    exports.getSqrefRawArrFormat = getSqrefRawArrFormat;
    function getSingleSequenceToNum(sqref) {
      var sqrefArray = sqref.match(/[A-Z]+|[0-9]+/g);
      var sqrefLen = sqrefArray.length;
      var regEn = new RegExp("^[A-Z]+$");
      var ret = "";
      for (var i = sqrefLen - 1; i >= 0; i--) {
        var cur = sqrefArray[i];
        if (regEn.test(cur)) {
          ret += ABCatNum(cur) + "_";
        } else {
          ret += parseInt(cur) - 1 + "_";
        }
      }
      return ret.substring(0, ret.length - 1);
    }
    exports.getSingleSequenceToNum = getSingleSequenceToNum;
    function getTransR1C1ToSequence(value) {
      if (!value && (value === null || value === void 0 ? void 0 : value.length) <= 0)
        return "";
      var len = value.length;
      var index = value.lastIndexOf("!");
      var valueArr = [value.slice(0, index), value.slice(index + 1, len)];
      var repStr = valueArr[1] || "";
      var indexR = repStr.indexOf("R");
      var indexC = repStr.indexOf("C");
      var row = Number(repStr.slice(indexR + 1, indexC));
      var column = chatatABC(Number(repStr.slice(indexC + 1, repStr === null || repStr === void 0 ? void 0 : repStr.length)) - 1);
      return "".concat(valueArr[0], "!").concat(column).concat(row);
    }
    exports.getTransR1C1ToSequence = getTransR1C1ToSequence;
    function getPeelOffX14(value) {
      var _a;
      if (!value || (value === null || value === void 0 ? void 0 : value.length) <= 0)
        return {};
      var formulaReg = new RegExp("</x14:formula[^]>", "g");
      var lastIndex = (_a = value.match(formulaReg)) === null || _a === void 0 ? void 0 : _a.length;
      var lastValue = "</x14:formula".concat(lastIndex, ">");
      var lastValueEnd = value.indexOf(lastValue);
      var formulaValue = value.substring(0, lastValueEnd + lastValue.length);
      formulaValue = formulaValue.replace(/<xm:f>/g, "").replace(/<\/xm:f>/g, "").replace(/x14:/g, "").replace(/\/x14:/g, "");
      var formula = formulaValue;
      var xmSqrefLen = "<xm:sqref>".length;
      var sqrefStart = value.indexOf("<xm:sqref>");
      var sqrefEnd = value.indexOf("</xm:sqref>");
      var sqref = value.substring(sqrefStart + xmSqrefLen, sqrefEnd);
      return {
        formula,
        sqref
      };
    }
    exports.getPeelOffX14 = getPeelOffX14;
    function getMultiFormulaValue(value) {
      var _a, _b;
      if (!value || (value === null || value === void 0 ? void 0 : value.length) <= 0)
        return [];
      var lenReg = new RegExp("formula", "g");
      var len = (((_a = value.match(lenReg)) === null || _a === void 0 ? void 0 : _a.length) || 0) / 2;
      if (len === 0)
        return [];
      var retArr = [];
      for (var i = 1; i <= len; i++) {
        var startLen = (_b = "<formula".concat(i, ">")) === null || _b === void 0 ? void 0 : _b.length;
        var start = value.indexOf("<formula".concat(i, ">"));
        var end = value.indexOf("</formula".concat(i, ">"));
        var _value = value.substring(start + startLen, end);
        retArr.push(escapeCharacter(_value.replace(/&quot;|^\"|\"$/g, "")));
      }
      return retArr;
    }
    exports.getMultiFormulaValue = getMultiFormulaValue;
    var setMerge = function(luckyMerge, worksheet) {
      if (luckyMerge === void 0) {
        luckyMerge = {};
      }
      var mergearr = Object.values(luckyMerge);
      mergearr.forEach(function(elem) {
        worksheet.mergeCells(elem.r + 1, elem.c + 1, elem.r + elem.rs, elem.c + elem.cs);
      });
    };
    exports.setMerge = setMerge;
    var getObjType = function(obj) {
      var toString = Object.prototype.toString;
      var map = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regExp",
        "[object Undefined]": "undefined",
        "[object Null]": "null",
        "[object Object]": "object"
      };
      return map[toString.call(obj)];
    };
    exports.getObjType = getObjType;
    var rgb2hex = function(rgb) {
      if (rgb.charAt(0) == "#") {
        return rgb;
      }
      var ds = rgb.split(/\D+/);
      var decimal = Number(ds[1]) * 65536 + Number(ds[2]) * 256 + Number(ds[3]);
      return "#" + zero_fill_hex(decimal, 6);
      function zero_fill_hex(num, digits) {
        var s = num.toString(16);
        while (s.length < digits)
          s = "0" + s;
        return s;
      }
    };
    exports.rgb2hex = rgb2hex;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/ReadXml.js
var require_ReadXml = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/ReadXml.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getlineStringAttr = exports.getColor = exports.Element = exports.ReadXml = void 0;
    var constant_1 = require_constant();
    var method_1 = require_method();
    var xmloperation = (
      /** @class */
      function() {
        function xmloperation2() {
        }
        xmloperation2.prototype.getElementsByOneTag = function(tag, file) {
          var readTagReg;
          if (tag.indexOf("|") > -1) {
            var tags = tag.split("|"), tagsRegTxt = "";
            for (var i = 0; i < tags.length; i++) {
              var t = tags[i];
              tagsRegTxt += "|<" + t + " [^>]+?[^/]>[\\s\\S]*?</" + t + ">|<" + t + " [^>]+?/>|<" + t + ">[\\s\\S]*?</" + t + ">|<" + t + "/>";
            }
            tagsRegTxt = tagsRegTxt.substr(1, tagsRegTxt.length);
            readTagReg = new RegExp(tagsRegTxt, "g");
          } else {
            readTagReg = new RegExp("<" + tag + " [^>]+?[^/]>[\\s\\S]*?</" + tag + ">|<" + tag + " [^>]+?/>|<" + tag + ">[\\s\\S]*?</" + tag + ">|<" + tag + "/>", "g");
          }
          var ret = file.match(readTagReg);
          if (ret == null) {
            return [];
          } else {
            return ret;
          }
        };
        return xmloperation2;
      }()
    );
    var ReadXml = (
      /** @class */
      function(_super) {
        __extends(ReadXml2, _super);
        function ReadXml2(files) {
          var _this = _super.call(this) || this;
          _this.originFile = files;
          return _this;
        }
        ReadXml2.prototype.getElementsByTagName = function(path, fileName) {
          var file = this.getFileByName(fileName);
          var pathArr = path.split("/"), ret;
          for (var key in pathArr) {
            var path_1 = pathArr[key];
            if (ret == void 0) {
              ret = this.getElementsByOneTag(path_1, file);
            } else {
              if (ret instanceof Array) {
                var items = [];
                for (var key_1 in ret) {
                  var item = ret[key_1];
                  items = items.concat(this.getElementsByOneTag(path_1, item));
                }
                ret = items;
              } else {
                ret = this.getElementsByOneTag(path_1, ret);
              }
            }
          }
          var elements = [];
          for (var i = 0; i < ret.length; i++) {
            var ele = new Element(ret[i]);
            elements.push(ele);
          }
          return elements;
        };
        ReadXml2.prototype.getFileByName = function(name) {
          for (var fileKey in this.originFile) {
            if (fileKey.indexOf(name) > -1) {
              return this.originFile[fileKey];
            }
          }
          return "";
        };
        return ReadXml2;
      }(xmloperation)
    );
    exports.ReadXml = ReadXml;
    var Element = (
      /** @class */
      function(_super) {
        __extends(Element2, _super);
        function Element2(str) {
          var _this = _super.call(this) || this;
          _this.elementString = str;
          _this.setValue();
          var readAttrReg = new RegExp('[a-zA-Z0-9_:]*?=".*?"', "g");
          var attrList = _this.container.match(readAttrReg);
          _this.attributeList = {};
          if (attrList != null) {
            for (var key in attrList) {
              var attrFull = attrList[key];
              if (attrFull.length == 0) {
                continue;
              }
              var attrKey = attrFull.substr(0, attrFull.indexOf("="));
              var attrValue = attrFull.substr(attrFull.indexOf("=") + 1);
              if (attrKey == null || attrValue == null || attrKey.length == 0 || attrValue.length == 0) {
                continue;
              }
              _this.attributeList[attrKey] = attrValue.substr(1, attrValue.length - 2);
            }
          }
          return _this;
        }
        Element2.prototype.get = function(name) {
          return this.attributeList[name];
        };
        Element2.prototype.getInnerElements = function(tag) {
          var ret = this.getElementsByOneTag(tag, this.elementString);
          var elements = [];
          for (var i = 0; i < ret.length; i++) {
            var ele = new Element2(ret[i]);
            elements.push(ele);
          }
          if (elements.length == 0) {
            return null;
          }
          return elements;
        };
        Element2.prototype.setValue = function() {
          var str = this.elementString;
          if (str.substr(str.length - 2, 2) == "/>") {
            this.value = "";
            this.container = str;
          } else {
            var firstTag = this.getFirstTag();
            var firstTagReg = new RegExp("(<" + firstTag + " [^>]+?[^/]>)([\\s\\S]*?)</" + firstTag + ">|(<" + firstTag + ">)([\\s\\S]*?)</" + firstTag + ">", "g");
            var result = firstTagReg.exec(str);
            if (result != null) {
              if (result[1] != null) {
                this.container = result[1];
                this.value = result[2];
              } else {
                this.container = result[3];
                this.value = result[4];
              }
            }
          }
        };
        Element2.prototype.getFirstTag = function() {
          var str = this.elementString;
          var firstTag = str.substr(0, str.indexOf(" "));
          if (firstTag == "" || firstTag.indexOf(">") > -1) {
            firstTag = str.substr(0, str.indexOf(">"));
          }
          firstTag = firstTag.substr(1, firstTag.length);
          return firstTag;
        };
        return Element2;
      }(xmloperation)
    );
    exports.Element = Element;
    function combineIndexedColor(indexedColorsInner, indexedColors) {
      var ret = {};
      if (indexedColorsInner == null || indexedColorsInner.length == 0) {
        return indexedColors;
      }
      for (var key in indexedColors) {
        var value = indexedColors[key], kn = parseInt(key);
        var inner = indexedColorsInner[kn];
        if (inner == null) {
          ret[key] = value;
        } else {
          var rgb = inner.attributeList.rgb;
          ret[key] = rgb;
        }
      }
      return ret;
    }
    function getColor(color, styles, type) {
      if (type === void 0) {
        type = "g";
      }
      var attrList = color.attributeList;
      var clrScheme = styles["clrScheme"];
      var indexedColorsInner = styles["indexedColors"];
      var mruColorsInner = styles["mruColors"];
      var indexedColorsList = combineIndexedColor(indexedColorsInner, constant_1.indexedColors);
      var indexed = attrList.indexed, rgb = attrList.rgb, theme = attrList.theme, tint = attrList.tint;
      var bg;
      if (indexed != null) {
        var indexedNum = parseInt(indexed);
        bg = indexedColorsList[indexedNum];
        if (bg != null) {
          bg = bg.substring(bg.length - 6, bg.length);
          bg = "#" + bg;
        }
      } else if (rgb != null) {
        rgb = rgb.substring(rgb.length - 6, rgb.length);
        bg = "#" + rgb;
      } else if (theme != null) {
        var themeNum = parseInt(theme);
        if (themeNum == 0) {
          themeNum = 1;
        } else if (themeNum == 1) {
          themeNum = 0;
        } else if (themeNum == 2) {
          themeNum = 3;
        } else if (themeNum == 3) {
          themeNum = 2;
        }
        var clrSchemeElement = clrScheme[themeNum];
        if (clrSchemeElement != null) {
          var clrs = clrSchemeElement.getInnerElements("a:sysClr|a:srgbClr");
          if (clrs != null) {
            var clr = clrs[0];
            var clrAttrList = clr.attributeList;
            if (clr.container.indexOf("sysClr") > -1) {
              if (clrAttrList.lastClr != null) {
                bg = "#" + clrAttrList.lastClr;
              } else if (clrAttrList.val != null) {
                bg = "#" + clrAttrList.val;
              }
            } else if (clr.container.indexOf("srgbClr") > -1) {
              bg = "#" + clrAttrList.val;
            }
          }
        }
      }
      if (tint != null) {
        var tintNum = parseFloat(tint);
        if (bg != null) {
          bg = (0, method_1.LightenDarkenColor)(bg, tintNum);
        }
      }
      return bg;
    }
    exports.getColor = getColor;
    function getlineStringAttr(frpr, attr) {
      var attrEle = frpr.getInnerElements(attr), value;
      if (attrEle != null && attrEle.length > 0) {
        if (attr == "b" || attr == "i" || attr == "strike") {
          value = "1";
        } else if (attr == "u") {
          var v = attrEle[0].attributeList.val;
          if (v == "double") {
            value = "2";
          } else if (v == "singleAccounting") {
            value = "3";
          } else if (v == "doubleAccounting") {
            value = "4";
          } else {
            value = "1";
          }
        } else if (attr == "vertAlign") {
          var v = attrEle[0].attributeList.val;
          if (v == "subscript") {
            value = "1";
          } else if (v == "superscript") {
            value = "2";
          }
        } else {
          value = attrEle[0].attributeList.val;
        }
      }
      return value;
    }
    exports.getlineStringAttr = getlineStringAttr;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneBase.js
var require_FortuneBase = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FortuneImageBase = exports.FortunesheetCalcChain = exports.FortuneSheetConfigMerge = exports.FortuneSheetborderInfoCellValueStyle = exports.FortuneSheetborderInfoCellValue = exports.FortuneSheetborderInfoCellForImp = exports.FortuneConfig = exports.FortuneInlineString = exports.FortuneSheetCellFormat = exports.FortuneSheetCelldataValue = exports.FortuneSheetCelldataBase = exports.FortuneFileInfo = exports.FortuneSheetBase = exports.FortuneFileBase = void 0;
    var FortuneFileBase = (
      /** @class */
      function() {
        function FortuneFileBase2() {
        }
        return FortuneFileBase2;
      }()
    );
    exports.FortuneFileBase = FortuneFileBase;
    var FortuneSheetBase = (
      /** @class */
      function() {
        function FortuneSheetBase2() {
        }
        return FortuneSheetBase2;
      }()
    );
    exports.FortuneSheetBase = FortuneSheetBase;
    var FortuneFileInfo = (
      /** @class */
      function() {
        function FortuneFileInfo2() {
        }
        return FortuneFileInfo2;
      }()
    );
    exports.FortuneFileInfo = FortuneFileInfo;
    var FortuneSheetCelldataBase = (
      /** @class */
      function() {
        function FortuneSheetCelldataBase2() {
        }
        return FortuneSheetCelldataBase2;
      }()
    );
    exports.FortuneSheetCelldataBase = FortuneSheetCelldataBase;
    var FortuneSheetCelldataValue = (
      /** @class */
      function() {
        function FortuneSheetCelldataValue2() {
        }
        return FortuneSheetCelldataValue2;
      }()
    );
    exports.FortuneSheetCelldataValue = FortuneSheetCelldataValue;
    var FortuneSheetCellFormat = (
      /** @class */
      function() {
        function FortuneSheetCellFormat2() {
        }
        return FortuneSheetCellFormat2;
      }()
    );
    exports.FortuneSheetCellFormat = FortuneSheetCellFormat;
    var FortuneInlineString = (
      /** @class */
      function() {
        function FortuneInlineString2() {
        }
        return FortuneInlineString2;
      }()
    );
    exports.FortuneInlineString = FortuneInlineString;
    var FortuneConfig = (
      /** @class */
      function() {
        function FortuneConfig2() {
        }
        return FortuneConfig2;
      }()
    );
    exports.FortuneConfig = FortuneConfig;
    var FortuneSheetborderInfoCellForImp = (
      /** @class */
      function() {
        function FortuneSheetborderInfoCellForImp2() {
        }
        return FortuneSheetborderInfoCellForImp2;
      }()
    );
    exports.FortuneSheetborderInfoCellForImp = FortuneSheetborderInfoCellForImp;
    var FortuneSheetborderInfoCellValue = (
      /** @class */
      function() {
        function FortuneSheetborderInfoCellValue2() {
        }
        return FortuneSheetborderInfoCellValue2;
      }()
    );
    exports.FortuneSheetborderInfoCellValue = FortuneSheetborderInfoCellValue;
    var FortuneSheetborderInfoCellValueStyle = (
      /** @class */
      function() {
        function FortuneSheetborderInfoCellValueStyle2() {
        }
        return FortuneSheetborderInfoCellValueStyle2;
      }()
    );
    exports.FortuneSheetborderInfoCellValueStyle = FortuneSheetborderInfoCellValueStyle;
    var FortuneSheetConfigMerge = (
      /** @class */
      function() {
        function FortuneSheetConfigMerge2() {
        }
        return FortuneSheetConfigMerge2;
      }()
    );
    exports.FortuneSheetConfigMerge = FortuneSheetConfigMerge;
    var FortunesheetCalcChain = (
      /** @class */
      function() {
        function FortunesheetCalcChain2() {
        }
        return FortunesheetCalcChain2;
      }()
    );
    exports.FortunesheetCalcChain = FortunesheetCalcChain;
    var FortuneImageBase = (
      /** @class */
      function() {
        function FortuneImageBase2() {
        }
        return FortuneImageBase2;
      }()
    );
    exports.FortuneImageBase = FortuneImageBase;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneCell.js
var require_FortuneCell = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneCell.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FortuneSheetCelldata = void 0;
    var ReadXml_1 = require_ReadXml();
    var method_1 = require_method();
    var constant_1 = require_constant();
    var FortuneBase_1 = require_FortuneBase();
    var FortuneSheetCelldata = (
      /** @class */
      function(_super) {
        __extends(FortuneSheetCelldata2, _super);
        function FortuneSheetCelldata2(cell, styles, sharedStrings, mergeCells, sheetFile, ReadXml) {
          var _this = _super.call(this) || this;
          _this.cell = cell;
          _this.sheetFile = sheetFile;
          _this.styles = styles;
          _this.sharedStrings = sharedStrings;
          _this.readXml = ReadXml;
          _this.mergeCells = mergeCells;
          var attrList = cell.attributeList;
          var r = attrList.r, s = attrList.s, t = attrList.t;
          var range = (0, method_1.getcellrange)(r);
          _this.r = range.row[0];
          _this.c = range.column[0];
          _this.v = _this.generateValue(s, t);
          return _this;
        }
        FortuneSheetCelldata2.prototype.generateValue = function(s, t) {
          var _this = this;
          var v = this.cell.getInnerElements("v");
          var f = this.cell.getInnerElements("f");
          if (v == null) {
            v = this.cell.getInnerElements("t");
          }
          var cellXfs = this.styles["cellXfs"];
          var cellStyleXfs = this.styles["cellStyleXfs"];
          var cellStyles = this.styles["cellStyles"];
          var fonts = this.styles["fonts"];
          var fills = this.styles["fills"];
          var borders = this.styles["borders"];
          var numfmts = this.styles["numfmts"];
          var clrScheme = this.styles["clrScheme"];
          var sharedStrings = this.sharedStrings;
          var cellValue = new FortuneBase_1.FortuneSheetCelldataValue();
          if (f != null) {
            var formula = f[0], attrList = formula.attributeList;
            var t_1 = attrList.t, ref = attrList.ref, si = attrList.si;
            var formulaValue = f[0].value;
            if (t_1 == "shared") {
              this._fomulaRef = ref;
              this._formulaType = t_1;
              this._formulaSi = si;
            }
            if (ref != null || formulaValue != null && formulaValue.length > 0) {
              formulaValue = (0, method_1.escapeCharacter)(formulaValue);
              cellValue.f = (formulaValue.startsWith("=") ? "" : "=") + formulaValue;
            }
          }
          var familyFont = null;
          var quotePrefix;
          if (s != null) {
            var sNum = parseInt(s);
            var cellXf = cellXfs[sNum];
            var xfId = cellXf.attributeList.xfId;
            var numFmtId = void 0, fontId = void 0, fillId = void 0, borderId = void 0;
            var horizontal = void 0, vertical = void 0, wrapText = void 0, textRotation = void 0, shrinkToFit = void 0, indent = void 0, applyProtection = void 0;
            if (xfId != null) {
              var cellStyleXf = cellStyleXfs[parseInt(xfId)];
              var attrList = cellStyleXf.attributeList;
              var applyNumberFormat_1 = attrList.applyNumberFormat;
              var applyFont_1 = attrList.applyFont;
              var applyFill_1 = attrList.applyFill;
              var applyBorder_1 = attrList.applyBorder;
              var applyAlignment_1 = attrList.applyAlignment;
              applyProtection = attrList.applyProtection;
              quotePrefix = attrList.quotePrefix;
              if (applyNumberFormat_1 != "0" && attrList.numFmtId != null) {
                numFmtId = attrList.numFmtId;
              }
              if (applyFont_1 != "0" && attrList.fontId != null) {
                fontId = attrList.fontId;
              }
              if (applyFill_1 != "0" && attrList.fillId != null) {
                fillId = attrList.fillId;
              }
              if (applyBorder_1 != "0" && attrList.borderId != null) {
                borderId = attrList.borderId;
              }
              if (applyAlignment_1 != null && applyAlignment_1 != "0") {
                var alignment = cellStyleXf.getInnerElements("alignment");
                if (alignment != null) {
                  var attrList_1 = alignment[0].attributeList;
                  if (attrList_1.horizontal != null) {
                    horizontal = attrList_1.horizontal;
                  }
                  if (attrList_1.vertical != null) {
                    vertical = attrList_1.vertical;
                  }
                  if (attrList_1.wrapText != null) {
                    wrapText = attrList_1.wrapText;
                  }
                  if (attrList_1.textRotation != null) {
                    textRotation = attrList_1.textRotation;
                  }
                  if (attrList_1.shrinkToFit != null) {
                    shrinkToFit = attrList_1.shrinkToFit;
                  }
                  if (attrList_1.indent != null) {
                    indent = attrList_1.indent;
                  }
                }
              }
            }
            var applyNumberFormat = cellXf.attributeList.applyNumberFormat;
            var applyFont = cellXf.attributeList.applyFont;
            var applyFill = cellXf.attributeList.applyFill;
            var applyBorder = cellXf.attributeList.applyBorder;
            var applyAlignment = cellXf.attributeList.applyAlignment;
            if (cellXf.attributeList.applyProtection != null) {
              applyProtection = cellXf.attributeList.applyProtection;
            }
            if (cellXf.attributeList.quotePrefix != null) {
              quotePrefix = cellXf.attributeList.quotePrefix;
            }
            if (applyNumberFormat != "0" && cellXf.attributeList.numFmtId != null) {
              numFmtId = cellXf.attributeList.numFmtId;
            }
            if (applyFont != "0") {
              fontId = cellXf.attributeList.fontId;
            }
            if (applyFill != "0") {
              fillId = cellXf.attributeList.fillId;
            }
            if (applyBorder != "0") {
              borderId = cellXf.attributeList.borderId;
            }
            if (applyAlignment != "0") {
              var alignment = cellXf.getInnerElements("alignment");
              if (alignment != null && alignment.length > 0) {
                var attrList = alignment[0].attributeList;
                if (attrList.horizontal != null) {
                  horizontal = attrList.horizontal;
                }
                if (attrList.vertical != null) {
                  vertical = attrList.vertical;
                }
                if (attrList.wrapText != null) {
                  wrapText = attrList.wrapText;
                }
                if (attrList.textRotation != null) {
                  textRotation = attrList.textRotation;
                }
                if (attrList.shrinkToFit != null) {
                  shrinkToFit = attrList.shrinkToFit;
                }
                if (attrList.indent != null) {
                  indent = attrList.indent;
                }
              }
            }
            if (numFmtId != void 0) {
              var numf = numfmts[parseInt(numFmtId)];
              var cellFormat = new FortuneBase_1.FortuneSheetCellFormat();
              cellFormat.fa = (0, method_1.escapeCharacter)(numf);
              cellFormat.t = t || "n";
              cellValue.ct = cellFormat;
            }
            if (fillId != void 0) {
              var fillIdNum = parseInt(fillId);
              var fill = fills[fillIdNum];
              var bg = this.getBackgroundByFill(fill, clrScheme);
              if (bg != null) {
                cellValue.bg = bg;
              }
            }
            if (fontId != void 0) {
              var fontIdNum = parseInt(fontId);
              var font = fonts[fontIdNum];
              if (font != null) {
                var sz = font.getInnerElements("sz");
                var colors = font.getInnerElements("color");
                var family = font.getInnerElements("name");
                var familyOverrides = font.getInnerElements("family");
                var charset = font.getInnerElements("charset");
                var bolds = font.getInnerElements("b");
                var italics = font.getInnerElements("i");
                var strikes = font.getInnerElements("strike");
                var underlines = font.getInnerElements("u");
                if (sz != null && sz.length > 0) {
                  var fs = sz[0].attributeList.val;
                  if (fs != null) {
                    cellValue.fs = parseInt(fs);
                  }
                }
                if (colors != null && colors.length > 0) {
                  var color = colors[0];
                  var fc = (0, ReadXml_1.getColor)(color, this.styles, "t");
                  if (fc != null) {
                    cellValue.fc = fc;
                  }
                }
                if (familyOverrides != null && familyOverrides.length > 0) {
                  var val = familyOverrides[0].attributeList.val;
                  if (val != null) {
                    familyFont = constant_1.fontFamilys[val];
                  }
                }
                if (family != null && family.length > 0) {
                  var val = family[0].attributeList.val;
                  if (val != null) {
                    cellValue.ff = val;
                  }
                }
                if (bolds != null && bolds.length > 0) {
                  var bold = bolds[0].attributeList.val;
                  if (bold == "0") {
                    cellValue.bl = 0;
                  } else {
                    cellValue.bl = 1;
                  }
                }
                if (italics != null && italics.length > 0) {
                  var italic = italics[0].attributeList.val;
                  if (italic == "0") {
                    cellValue.it = 0;
                  } else {
                    cellValue.it = 1;
                  }
                }
                if (strikes != null && strikes.length > 0) {
                  var strike = strikes[0].attributeList.val;
                  if (strike == "0") {
                    cellValue.cl = 0;
                  } else {
                    cellValue.cl = 1;
                  }
                }
                if (underlines != null && underlines.length > 0) {
                  var underline = underlines[0].attributeList.val;
                  if (underline == "single") {
                    cellValue.un = 1;
                  } else if (underline == "double") {
                    cellValue.un = 2;
                  } else if (underline == "singleAccounting") {
                    cellValue.un = 3;
                  } else if (underline == "doubleAccounting") {
                    cellValue.un = 4;
                  } else {
                    cellValue.un = 0;
                  }
                }
              }
            }
            if (horizontal != void 0) {
              if (horizontal == "center") {
                cellValue.ht = 0;
              } else if (horizontal == "centerContinuous") {
                cellValue.ht = 0;
              } else if (horizontal == "left") {
                cellValue.ht = 1;
              } else if (horizontal == "right") {
                cellValue.ht = 2;
              } else if (horizontal == "distributed") {
                cellValue.ht = 0;
              } else if (horizontal == "fill") {
                cellValue.ht = 1;
              } else if (horizontal == "general") {
                cellValue.ht = 1;
              } else if (horizontal == "justify") {
                cellValue.ht = 0;
              } else {
                cellValue.ht = 1;
              }
            }
            if (vertical != void 0) {
              if (vertical == "bottom") {
                cellValue.vt = 2;
              } else if (vertical == "center") {
                cellValue.vt = 0;
              } else if (vertical == "distributed") {
                cellValue.vt = 0;
              } else if (vertical == "justify") {
                cellValue.vt = 0;
              } else if (vertical == "top") {
                cellValue.vt = 1;
              } else {
                cellValue.vt = 1;
              }
            } else {
              cellValue.vt = 2;
            }
            if (wrapText != void 0) {
              if (wrapText == "1") {
                cellValue.tb = 2;
              } else {
                cellValue.tb = 1;
              }
            } else {
              cellValue.tb = 1;
            }
            if (textRotation != void 0) {
              if (textRotation == "255") {
                cellValue.tr = 3;
              } else {
                cellValue.tr = 0;
                cellValue.rt = parseInt(textRotation);
              }
            }
            if (shrinkToFit != void 0) {
            }
            if (indent != void 0) {
            }
            if (borderId != void 0) {
              var borderIdNum = parseInt(borderId);
              var border = borders[borderIdNum];
              var borderObject = new FortuneBase_1.FortuneSheetborderInfoCellForImp();
              borderObject.rangeType = "cell";
              var borderCellValue = new FortuneBase_1.FortuneSheetborderInfoCellValue();
              borderCellValue.row_index = this.r;
              borderCellValue.col_index = this.c;
              var lefts = border.getInnerElements("left");
              var rights = border.getInnerElements("right");
              var tops = border.getInnerElements("top");
              var bottoms = border.getInnerElements("bottom");
              var diagonals = border.getInnerElements("diagonal");
              var starts = border.getInnerElements("start");
              var ends = border.getInnerElements("end");
              var left = this.getBorderInfo(lefts);
              var right = this.getBorderInfo(rights);
              var top_1 = this.getBorderInfo(tops);
              var bottom = this.getBorderInfo(bottoms);
              var diagonal = this.getBorderInfo(diagonals);
              var start = this.getBorderInfo(starts);
              var end = this.getBorderInfo(ends);
              var isAdd = false;
              if (start != null && start.color != null) {
                borderCellValue.l = start;
                isAdd = true;
              }
              if (end != null && end.color != null) {
                borderCellValue.r = end;
                isAdd = true;
              }
              if (left != null && left.color != null) {
                borderCellValue.l = left;
                isAdd = true;
              }
              if (right != null && right.color != null) {
                borderCellValue.r = right;
                isAdd = true;
              }
              if (top_1 != null && top_1.color != null) {
                borderCellValue.t = top_1;
                isAdd = true;
              }
              if (bottom != null && bottom.color != null) {
                borderCellValue.b = bottom;
                isAdd = true;
              }
              if (isAdd) {
                borderObject.value = borderCellValue;
                this._borderObject = borderObject;
              }
            }
          } else {
            cellValue.tb = 1;
          }
          if (v != null) {
            var value = v[0].value;
            if (/&#\d+;/.test(value)) {
              value = this.htmlDecode(value);
            }
            if (t == constant_1.ST_CellType["SharedString"]) {
              var siIndex = parseInt(v[0].value);
              var sharedSI = sharedStrings[siIndex];
              var rFlag = sharedSI.getInnerElements("r");
              if (rFlag == null) {
                var tFlag = sharedSI.getInnerElements("t");
                if (tFlag != null) {
                  var text_1 = "";
                  tFlag.forEach(function(t2) {
                    text_1 += t2.value;
                  });
                  text_1 = (0, method_1.escapeCharacter)(text_1);
                  if (familyFont == "Roman" && text_1.length > 0) {
                    var textArray = text_1.split("");
                    var preWordType = null, wordText = "", preWholef = null;
                    var wholef = "Times New Roman";
                    if (cellValue.ff != null) {
                      wholef = cellValue.ff;
                    }
                    var cellFormat = cellValue.ct;
                    if (cellFormat == null) {
                      cellFormat = new FortuneBase_1.FortuneSheetCellFormat();
                    }
                    if (cellFormat.s == null) {
                      cellFormat.s = [];
                    }
                    for (var i = 0; i < textArray.length; i++) {
                      var w = textArray[i];
                      var type = null, ff = wholef;
                      if ((0, method_1.isChinese)(w)) {
                        type = "c";
                        ff = "宋体";
                      } else if ((0, method_1.isJapanese)(w)) {
                        type = "j";
                        ff = "Yu Gothic";
                      } else if ((0, method_1.isKoera)(w)) {
                        type = "k";
                        ff = "Malgun Gothic";
                      } else {
                        type = "e";
                      }
                      if (type != preWordType && preWordType != null || i == textArray.length - 1) {
                        var InlineString = {};
                        InlineString.ff = preWholef;
                        if (cellValue.fc != null) {
                          InlineString.fc = cellValue.fc;
                        }
                        if (cellValue.fs != null) {
                          InlineString.fs = cellValue.fs;
                        }
                        if (cellValue.cl != null) {
                          InlineString.cl = cellValue.cl;
                        }
                        if (cellValue.un != null) {
                          InlineString.un = cellValue.un;
                        }
                        if (cellValue.bl != null) {
                          InlineString.bl = cellValue.bl;
                        }
                        if (cellValue.it != null) {
                          InlineString.it = cellValue.it;
                        }
                        if (i == textArray.length - 1) {
                          if (type == preWordType) {
                            InlineString.ff = ff;
                            InlineString.v = wordText + w;
                          } else {
                            InlineString.ff = preWholef;
                            InlineString.v = wordText;
                            cellFormat.s.push(InlineString);
                            var InlineStringLast = {};
                            InlineStringLast.ff = ff;
                            InlineStringLast.v = w;
                            if (cellValue.fc != null) {
                              InlineStringLast.fc = cellValue.fc;
                            }
                            if (cellValue.fs != null) {
                              InlineStringLast.fs = cellValue.fs;
                            }
                            if (cellValue.cl != null) {
                              InlineStringLast.cl = cellValue.cl;
                            }
                            if (cellValue.un != null) {
                              InlineStringLast.un = cellValue.un;
                            }
                            if (cellValue.bl != null) {
                              InlineStringLast.bl = cellValue.bl;
                            }
                            if (cellValue.it != null) {
                              InlineStringLast.it = cellValue.it;
                            }
                            cellFormat.s.push(InlineStringLast);
                            break;
                          }
                        } else {
                          InlineString.v = wordText;
                        }
                        cellFormat.s.push(InlineString);
                        wordText = w;
                      } else {
                        wordText += w;
                      }
                      preWordType = type;
                      preWholef = ff;
                    }
                    cellFormat.t = "inlineStr";
                    cellValue.ct = cellFormat;
                  } else {
                    text_1 = this.replaceSpecialWrap(text_1);
                    if (text_1.indexOf("\r\n") > -1 || text_1.indexOf("\n") > -1) {
                      var InlineString = {};
                      InlineString.v = text_1;
                      var cellFormat = cellValue.ct;
                      if (cellFormat == null) {
                        cellFormat = new FortuneBase_1.FortuneSheetCellFormat();
                      }
                      if (cellValue.ff != null) {
                        InlineString.ff = cellValue.ff;
                      }
                      if (cellValue.fc != null) {
                        InlineString.fc = cellValue.fc;
                      }
                      if (cellValue.fs != null) {
                        InlineString.fs = cellValue.fs;
                      }
                      if (cellValue.cl != null) {
                        InlineString.cl = cellValue.cl;
                      }
                      if (cellValue.un != null) {
                        InlineString.un = cellValue.un;
                      }
                      if (cellValue.bl != null) {
                        InlineString.bl = cellValue.bl;
                      }
                      if (cellValue.it != null) {
                        InlineString.it = cellValue.it;
                      }
                      cellFormat.t = "inlineStr";
                      cellFormat.s = [InlineString];
                      cellValue.ct = cellFormat;
                    } else {
                      cellValue.v = text_1;
                      quotePrefix = "1";
                    }
                  }
                }
              } else {
                var styles_1 = [];
                rFlag.forEach(function(r) {
                  var tFlag2 = r.getInnerElements("t");
                  var rPr = r.getInnerElements("rPr");
                  var InlineString2 = {};
                  if (tFlag2 != null && tFlag2.length > 0) {
                    var text = tFlag2[0].value;
                    text = _this.replaceSpecialWrap(text);
                    text = (0, method_1.escapeCharacter)(text);
                    InlineString2.v = text;
                  }
                  if (rPr != null && rPr.length > 0) {
                    var frpr = rPr[0];
                    var sz2 = (0, ReadXml_1.getlineStringAttr)(frpr, "sz"), rFont = (0, ReadXml_1.getlineStringAttr)(frpr, "rFont"), family2 = (0, ReadXml_1.getlineStringAttr)(frpr, "family"), charset2 = (0, ReadXml_1.getlineStringAttr)(frpr, "charset"), scheme = (0, ReadXml_1.getlineStringAttr)(frpr, "scheme"), b = (0, ReadXml_1.getlineStringAttr)(frpr, "b"), i2 = (0, ReadXml_1.getlineStringAttr)(frpr, "i"), u = (0, ReadXml_1.getlineStringAttr)(frpr, "u"), strike2 = (0, ReadXml_1.getlineStringAttr)(frpr, "strike"), vertAlign = (0, ReadXml_1.getlineStringAttr)(frpr, "vertAlign"), color2 = void 0;
                    var cEle = frpr.getInnerElements("color");
                    if (cEle != null && cEle.length > 0) {
                      color2 = (0, ReadXml_1.getColor)(cEle[0], _this.styles, "t");
                    }
                    var ff2 = void 0;
                    if (rFont != null) {
                      ff2 = rFont;
                    }
                    if (ff2 != null) {
                      InlineString2.ff = ff2;
                    } else if (cellValue.ff != null) {
                      InlineString2.ff = cellValue.ff;
                    }
                    if (color2 != null) {
                      InlineString2.fc = color2;
                    } else if (cellValue.fc != null) {
                      InlineString2.fc = cellValue.fc;
                    }
                    if (sz2 != null) {
                      InlineString2.fs = parseInt(sz2);
                    } else if (cellValue.fs != null) {
                      InlineString2.fs = cellValue.fs;
                    }
                    if (strike2 != null) {
                      InlineString2.cl = parseInt(strike2);
                    } else if (cellValue.cl != null) {
                      InlineString2.cl = cellValue.cl;
                    }
                    if (u != null) {
                      InlineString2.un = parseInt(u);
                    } else if (cellValue.un != null) {
                      InlineString2.un = cellValue.un;
                    }
                    if (b != null) {
                      InlineString2.bl = parseInt(b);
                    } else if (cellValue.bl != null) {
                      InlineString2.bl = cellValue.bl;
                    }
                    if (i2 != null) {
                      InlineString2.it = parseInt(i2);
                    } else if (cellValue.it != null) {
                      InlineString2.it = cellValue.it;
                    }
                    if (vertAlign != null) {
                      InlineString2.va = parseInt(vertAlign);
                    }
                  } else {
                    if (InlineString2.ff == null && cellValue.ff != null) {
                      InlineString2.ff = cellValue.ff;
                    }
                    if (InlineString2.fc == null && cellValue.fc != null) {
                      InlineString2.fc = cellValue.fc;
                    }
                    if (InlineString2.fs == null && cellValue.fs != null) {
                      InlineString2.fs = cellValue.fs;
                    }
                    if (InlineString2.cl == null && cellValue.cl != null) {
                      InlineString2.cl = cellValue.cl;
                    }
                    if (InlineString2.un == null && cellValue.un != null) {
                      InlineString2.un = cellValue.un;
                    }
                    if (InlineString2.bl == null && cellValue.bl != null) {
                      InlineString2.bl = cellValue.bl;
                    }
                    if (InlineString2.it == null && cellValue.it != null) {
                      InlineString2.it = cellValue.it;
                    }
                  }
                  styles_1.push(InlineString2);
                });
                var cellFormat = cellValue.ct;
                if (cellFormat == null) {
                  cellFormat = new FortuneBase_1.FortuneSheetCellFormat();
                }
                cellFormat.t = "inlineStr";
                cellFormat.s = styles_1;
                cellValue.ct = cellFormat;
              }
            } else if (t == constant_1.ST_CellType["InlineString"] && v != null) {
              cellValue.v = "'" + value;
            } else {
              value = (0, method_1.escapeCharacter)(value);
              cellValue.v = value;
            }
          }
          if (quotePrefix != null) {
            cellValue.qp = parseInt(quotePrefix);
          }
          return cellValue;
        };
        FortuneSheetCelldata2.prototype.replaceSpecialWrap = function(text) {
          text = text.replace(/_x000D_/g, "").replace(/&#13;&#10;/g, "\r\n").replace(/&#13;/g, "\r").replace(/&#10;/g, "\n");
          return text;
        };
        FortuneSheetCelldata2.prototype.getBackgroundByFill = function(fill, clrScheme) {
          var patternFills = fill.getInnerElements("patternFill");
          if (patternFills != null) {
            var patternFill = patternFills[0];
            var fgColors = patternFill.getInnerElements("fgColor");
            var bgColors = patternFill.getInnerElements("bgColor");
            var fg = void 0, bg = void 0;
            if (fgColors != null) {
              var fgColor = fgColors[0];
              fg = (0, ReadXml_1.getColor)(fgColor, this.styles);
            }
            if (bgColors != null) {
              var bgColor = bgColors[0];
              bg = (0, ReadXml_1.getColor)(bgColor, this.styles);
            }
            if (fg != null) {
              return fg;
            } else if (bg != null) {
              return bg;
            }
          } else {
            var gradientfills = fill.getInnerElements("gradientFill");
            if (gradientfills != null) {
              return null;
            }
          }
        };
        FortuneSheetCelldata2.prototype.getBorderInfo = function(borders) {
          if (borders == null) {
            return null;
          }
          var border = borders[0], attrList = border.attributeList;
          var clrScheme = this.styles["clrScheme"];
          var style = attrList.style;
          if (style == null || style == "none") {
            return null;
          }
          var colors = border.getInnerElements("color");
          var colorRet = "#000000";
          if (colors != null) {
            var color = colors[0];
            colorRet = (0, ReadXml_1.getColor)(color, this.styles, "b");
            if (colorRet == null) {
              colorRet = "#000000";
            }
          }
          var ret = new FortuneBase_1.FortuneSheetborderInfoCellValueStyle();
          ret.style = constant_1.borderTypes[style];
          ret.color = colorRet;
          return ret;
        };
        FortuneSheetCelldata2.prototype.htmlDecode = function(str) {
          return str.replace(/&#(x)?([^&]{1,5});/g, function($, $1, $2) {
            return String.fromCharCode(parseInt($2, $1 ? 16 : 10));
          });
        };
        return FortuneSheetCelldata2;
      }(FortuneBase_1.FortuneSheetCelldataBase)
    );
    exports.FortuneSheetCelldata = FortuneSheetCelldata;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneSheet.js
var require_FortuneSheet = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneSheet.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FortuneSheet = void 0;
    var FortuneCell_1 = require_FortuneCell();
    var method_1 = require_method();
    var constant_1 = require_constant();
    var ReadXml_1 = require_ReadXml();
    var FortuneBase_1 = require_FortuneBase();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var FortuneSheet = (
      /** @class */
      function(_super) {
        __extends(FortuneSheet2, _super);
        function FortuneSheet2(sheetName, sheetId, sheetOrder, isInitialCell, allFileOption) {
          if (isInitialCell === void 0) {
            isInitialCell = false;
          }
          var _this = _super.call(this) || this;
          _this.isInitialCell = isInitialCell;
          _this.readXml = allFileOption.readXml;
          _this.sheetFile = allFileOption.sheetFile;
          _this.styles = allFileOption.styles;
          _this.sharedStrings = allFileOption.sharedStrings;
          _this.calcChainEles = allFileOption.calcChain;
          _this.sheetList = allFileOption.sheetList;
          _this.imageList = allFileOption.imageList;
          _this.hide = allFileOption.hide;
          _this.name = sheetName;
          _this.id = sheetId;
          _this.order = sheetOrder.toString();
          _this.config = new FortuneBase_1.FortuneConfig();
          _this.celldata = [];
          _this.mergeCells = _this.readXml.getElementsByTagName("mergeCells/mergeCell", _this.sheetFile);
          var clrScheme = _this.styles["clrScheme"];
          var sheetView = _this.readXml.getElementsByTagName("sheetViews/sheetView", _this.sheetFile);
          var showGridLines = "1", tabSelected = "0", zoomScale = "100", activeCell = "A1";
          if (sheetView.length > 0) {
            var attrList = sheetView[0].attributeList;
            showGridLines = (0, method_1.getXmlAttibute)(attrList, "showGridLines", "1");
            tabSelected = (0, method_1.getXmlAttibute)(attrList, "tabSelected", "0");
            zoomScale = (0, method_1.getXmlAttibute)(attrList, "zoomScale", "100");
            var selections = sheetView[0].getInnerElements("selection");
            if (selections != null && selections.length > 0) {
              activeCell = (0, method_1.getXmlAttibute)(selections[0].attributeList, "activeCell", "A1");
              var range = (0, method_1.getcellrange)(activeCell, _this.sheetList, sheetId);
              _this.luckysheet_select_save = [];
              _this.luckysheet_select_save.push(range);
            }
          }
          _this.showGridLines = showGridLines;
          _this.status = tabSelected;
          _this.zoomRatio = parseInt(zoomScale) / 100;
          var tabColors = _this.readXml.getElementsByTagName("sheetPr/tabColor", _this.sheetFile);
          if (tabColors != null && tabColors.length > 0) {
            var tabColor = tabColors[0], attrList = tabColor.attributeList;
            var tc = (0, ReadXml_1.getColor)(tabColor, _this.styles, "b");
            _this.color = tc;
          }
          var sheetFormatPr = _this.readXml.getElementsByTagName("sheetFormatPr", _this.sheetFile);
          var defaultColWidth, defaultRowHeight;
          if (sheetFormatPr.length > 0) {
            var attrList = sheetFormatPr[0].attributeList;
            defaultColWidth = (0, method_1.getXmlAttibute)(attrList, "defaultColWidth", "9.21");
            defaultRowHeight = (0, method_1.getXmlAttibute)(attrList, "defaultRowHeight", "19");
          }
          _this.defaultColWidth = (0, method_1.getColumnWidthPixel)(parseFloat(defaultColWidth));
          _this.defaultRowHeight = (0, method_1.getRowHeightPixel)(parseFloat(defaultRowHeight));
          _this.generateConfigColumnLenAndHidden();
          var cellOtherInfo = _this.generateConfigRowLenAndHiddenAddCell();
          if (_this.calcChain == null) {
            _this.calcChain = [];
          }
          var formulaListExist = {};
          for (var c = 0; c < _this.calcChainEles.length; c++) {
            var calcChainEle = _this.calcChainEles[c], attrList = calcChainEle.attributeList;
            if (attrList.i != sheetId) {
              continue;
            }
            var r = attrList.r, i = attrList.i, l = attrList.l, s = attrList.s, a = attrList.a, t = attrList.t;
            var range = (0, method_1.getcellrange)(r);
            var chain = new FortuneBase_1.FortunesheetCalcChain();
            chain.r = range.row[0];
            chain.c = range.column[0];
            chain.id = _this.id;
            _this.calcChain.push(chain);
            formulaListExist["r" + r + "c" + c] = null;
          }
          if (_this.formulaRefList != null) {
            for (var key in _this.formulaRefList) {
              var funclist = _this.formulaRefList[key];
              var mainFunc = funclist["mainRef"], mainCellValue = mainFunc.cellValue;
              var formulaTxt = mainFunc.fv;
              var mainR = mainCellValue.r, mainC = mainCellValue.c;
              for (var name_1 in funclist) {
                if (name_1 == "mainRef") {
                  continue;
                }
                var funcValue = funclist[name_1], cellValue = funcValue.cellValue;
                if (cellValue == null) {
                  continue;
                }
                var r = cellValue.r, c = cellValue.c;
                var func = formulaTxt;
                var offsetRow = r - mainR, offsetCol = c - mainC;
                if (offsetRow > 0) {
                  func = "=" + method_1.fromulaRef.functionCopy(func, "down", offsetRow);
                } else if (offsetRow < 0) {
                  func = "=" + method_1.fromulaRef.functionCopy(func, "up", Math.abs(offsetRow));
                }
                if (offsetCol > 0) {
                  func = "=" + method_1.fromulaRef.functionCopy(func, "right", offsetCol);
                } else if (offsetCol < 0) {
                  func = "=" + method_1.fromulaRef.functionCopy(func, "left", Math.abs(offsetCol));
                }
                cellValue.v.f = func;
                var chain = new FortuneBase_1.FortunesheetCalcChain();
                chain.r = cellValue.r;
                chain.c = cellValue.c;
                chain.id = _this.id;
                _this.calcChain.push(chain);
              }
            }
          }
          for (var key in cellOtherInfo.formulaList) {
            if (!(key in formulaListExist)) {
              var formulaListItem = cellOtherInfo.formulaList[key];
              var chain = new FortuneBase_1.FortunesheetCalcChain();
              chain.r = formulaListItem.r;
              chain.c = formulaListItem.c;
              chain.id = _this.id;
              _this.calcChain.push(chain);
            }
          }
          _this.dataVerification = _this.generateConfigDataValidations();
          _this.hyperlink = _this.generateConfigHyperlinks();
          _this.hide = _this.hide;
          if (_this.mergeCells != null) {
            for (var i = 0; i < _this.mergeCells.length; i++) {
              var merge = _this.mergeCells[i], attrList = merge.attributeList;
              var ref = attrList.ref;
              if (ref == null) {
                continue;
              }
              var range = (0, method_1.getcellrange)(ref, _this.sheetList, sheetId);
              var mergeValue = new FortuneBase_1.FortuneSheetConfigMerge();
              mergeValue.r = range.row[0];
              mergeValue.c = range.column[0];
              mergeValue.rs = range.row[1] - range.row[0] + 1;
              mergeValue.cs = range.column[1] - range.column[0] + 1;
              if (_this.config.merge == null) {
                _this.config.merge = {};
              }
              _this.config.merge[range.row[0] + "_" + range.column[0]] = mergeValue;
            }
          }
          var drawingFile = allFileOption.drawingFile, drawingRelsFile = allFileOption.drawingRelsFile;
          if (drawingFile != null && drawingRelsFile != null) {
            var twoCellAnchors = _this.readXml.getElementsByTagName("xdr:twoCellAnchor", drawingFile);
            if (twoCellAnchors != null && twoCellAnchors.length > 0) {
              for (var i = 0; i < twoCellAnchors.length; i++) {
                var twoCellAnchor = twoCellAnchors[i];
                var editAs = (0, method_1.getXmlAttibute)(twoCellAnchor.attributeList, "editAs", "twoCell");
                var xdrFroms = twoCellAnchor.getInnerElements("xdr:from"), xdrTos = twoCellAnchor.getInnerElements("xdr:to");
                var xdr_blipfills = twoCellAnchor.getInnerElements("a:blip");
                if (xdrFroms != null && xdr_blipfills != null && xdrFroms.length > 0 && xdr_blipfills.length > 0) {
                  var xdrFrom = xdrFroms[0], xdrTo = xdrTos[0], xdr_blipfill = xdr_blipfills[0];
                  var rembed = (0, method_1.getXmlAttibute)(xdr_blipfill.attributeList, "r:embed", null);
                  var imageObject = _this.getBase64ByRid(rembed, drawingRelsFile);
                  var x_n = 0, y_n = 0;
                  var cx_n = 0, cy_n = 0;
                  imageObject.fromCol = _this.getXdrValue(xdrFrom.getInnerElements("xdr:col"));
                  imageObject.fromColOff = (0, method_1.getPxByEMUs)(_this.getXdrValue(xdrFrom.getInnerElements("xdr:colOff")));
                  imageObject.fromRow = _this.getXdrValue(xdrFrom.getInnerElements("xdr:row"));
                  imageObject.fromRowOff = (0, method_1.getPxByEMUs)(_this.getXdrValue(xdrFrom.getInnerElements("xdr:rowOff")));
                  imageObject.toCol = _this.getXdrValue(xdrTo.getInnerElements("xdr:col"));
                  imageObject.toColOff = (0, method_1.getPxByEMUs)(_this.getXdrValue(xdrTo.getInnerElements("xdr:colOff")));
                  imageObject.toRow = _this.getXdrValue(xdrTo.getInnerElements("xdr:row"));
                  imageObject.toRowOff = (0, method_1.getPxByEMUs)(_this.getXdrValue(xdrTo.getInnerElements("xdr:rowOff")));
                  imageObject.originWidth = cx_n;
                  imageObject.originHeight = cy_n;
                  if (editAs == "absolute") {
                    imageObject.type = "3";
                  } else if (editAs == "oneCell") {
                    imageObject.type = "2";
                  } else {
                    imageObject.type = "1";
                  }
                  imageObject.isFixedPos = false;
                  imageObject.fixedLeft = 0;
                  imageObject.fixedTop = 0;
                  var imageBorder = {
                    color: "#000",
                    radius: 0,
                    style: "solid",
                    width: 0
                  };
                  imageObject.border = imageBorder;
                  var imageCrop = {
                    height: cy_n,
                    offsetLeft: 0,
                    offsetTop: 0,
                    width: cx_n
                  };
                  imageObject.crop = imageCrop;
                  var imageDefault = {
                    height: cy_n,
                    left: x_n,
                    top: y_n,
                    width: cx_n
                  };
                  imageObject.default = imageDefault;
                  if (_this.images == null) {
                    _this.images = {};
                  }
                  _this.images[(0, method_1.generateRandomIndex)("image")] = imageObject;
                }
              }
            }
          }
          return _this;
        }
        FortuneSheet2.prototype.getXdrValue = function(ele) {
          if (ele == null || ele.length == 0) {
            return null;
          }
          return parseInt(ele[0].value);
        };
        FortuneSheet2.prototype.getBase64ByRid = function(rid, drawingRelsFile) {
          var Relationships = this.readXml.getElementsByTagName("Relationships/Relationship", drawingRelsFile);
          if (Relationships != null && Relationships.length > 0) {
            for (var i = 0; i < Relationships.length; i++) {
              var Relationship = Relationships[i];
              var attrList = Relationship.attributeList;
              var Id = (0, method_1.getXmlAttibute)(attrList, "Id", null);
              var src = (0, method_1.getXmlAttibute)(attrList, "Target", null);
              if (Id == rid) {
                src = src.replace(/\.\.\//g, "");
                src = "xl/" + src;
                var imgage = this.imageList.getImageByName(src);
                return imgage;
              }
            }
          }
          return null;
        };
        FortuneSheet2.prototype.generateConfigColumnLenAndHidden = function() {
          var cols = this.readXml.getElementsByTagName("cols/col", this.sheetFile);
          for (var i = 0; i < cols.length; i++) {
            var col = cols[i], attrList = col.attributeList;
            var min = (0, method_1.getXmlAttibute)(attrList, "min", null);
            var max = (0, method_1.getXmlAttibute)(attrList, "max", null);
            var width = (0, method_1.getXmlAttibute)(attrList, "width", null);
            var hidden = (0, method_1.getXmlAttibute)(attrList, "hidden", null);
            var customWidth = (0, method_1.getXmlAttibute)(attrList, "customWidth", null);
            if (min == null || max == null) {
              continue;
            }
            var minNum = parseInt(min) - 1, maxNum = parseInt(max) - 1, widthNum = parseFloat(width);
            for (var m = minNum; m <= maxNum; m++) {
              if (width != null) {
                if (this.config.columnlen == null) {
                  this.config.columnlen = {};
                }
                this.config.columnlen[m] = (0, method_1.getColumnWidthPixel)(widthNum);
              }
              if (hidden == "1") {
                if (this.config.colhidden == null) {
                  this.config.colhidden = {};
                }
                this.config.colhidden[m] = 0;
                if (this.config.columnlen) {
                  delete this.config.columnlen[m];
                }
              }
              if (customWidth != null) {
                if (this.config.customWidth == null) {
                  this.config.customWidth = {};
                }
                this.config.customWidth[m] = 1;
              }
            }
          }
        };
        FortuneSheet2.prototype.generateConfigRowLenAndHiddenAddCell = function() {
          var rows = this.readXml.getElementsByTagName("sheetData/row", this.sheetFile);
          var cellOtherInfo = {};
          var formulaList = {};
          cellOtherInfo.formulaList = formulaList;
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i], attrList = row.attributeList;
            var rowNo = (0, method_1.getXmlAttibute)(attrList, "r", null);
            var height = (0, method_1.getXmlAttibute)(attrList, "ht", null);
            var hidden = (0, method_1.getXmlAttibute)(attrList, "hidden", null);
            var customHeight = (0, method_1.getXmlAttibute)(attrList, "customHeight", null);
            if (rowNo == null) {
              continue;
            }
            var rowNoNum = parseInt(rowNo) - 1;
            if (height != null) {
              var heightNum = parseFloat(height);
              if (this.config.rowlen == null) {
                this.config.rowlen = {};
              }
              this.config.rowlen[rowNoNum] = (0, method_1.getRowHeightPixel)(heightNum);
            }
            if (hidden == "1") {
              if (this.config.rowhidden == null) {
                this.config.rowhidden = {};
              }
              this.config.rowhidden[rowNoNum] = 0;
              if (this.config.rowlen) {
                delete this.config.rowlen[rowNoNum];
              }
            }
            if (customHeight != null) {
              if (this.config.customHeight == null) {
                this.config.customHeight = {};
              }
              this.config.customHeight[rowNoNum] = 1;
            }
            if (this.isInitialCell) {
              var cells = row.getInnerElements("c");
              for (var key in cells) {
                var cell = cells[key];
                var cellValue = new FortuneCell_1.FortuneSheetCelldata(cell, this.styles, this.sharedStrings, this.mergeCells, this.sheetFile, this.readXml);
                if (cellValue._borderObject != null) {
                  if (this.config.borderInfo == null) {
                    this.config.borderInfo = [];
                  }
                  this.config.borderInfo.push(cellValue._borderObject);
                  delete cellValue._borderObject;
                }
                if (cellValue._formulaType == "shared") {
                  if (this.formulaRefList == null) {
                    this.formulaRefList = {};
                  }
                  if (this.formulaRefList[cellValue._formulaSi] == null) {
                    this.formulaRefList[cellValue._formulaSi] = {};
                  }
                  var fv = void 0;
                  if (cellValue.v != null) {
                    fv = cellValue.v.f;
                  }
                  var refValue = {
                    t: cellValue._formulaType,
                    ref: cellValue._fomulaRef,
                    si: cellValue._formulaSi,
                    fv,
                    cellValue
                  };
                  if (cellValue._fomulaRef != null) {
                    this.formulaRefList[cellValue._formulaSi]["mainRef"] = refValue;
                  } else {
                    this.formulaRefList[cellValue._formulaSi][cellValue.r + "_" + cellValue.c] = refValue;
                  }
                }
                if (cellValue.v != null && cellValue.v.f != null) {
                  var formulaCell = {
                    r: cellValue.r,
                    c: cellValue.c
                  };
                  cellOtherInfo.formulaList["r" + cellValue.r + "c" + cellValue.c] = formulaCell;
                }
                this.celldata.push(cellValue);
              }
            }
          }
          return cellOtherInfo;
        };
        FortuneSheet2.prototype.generateConfigDataValidations = function() {
          var rows = this.readXml.getElementsByTagName("dataValidations/dataValidation", this.sheetFile);
          var extLst = this.readXml.getElementsByTagName("extLst/ext/x14:dataValidations/x14:dataValidation", this.sheetFile) || [];
          rows = rows.concat(extLst);
          var dataVerification = {};
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            var attrList = row.attributeList;
            var formulaValue = row.value;
            var type = (0, method_1.getXmlAttibute)(attrList, "type", null);
            if (!type) {
              continue;
            }
            var operator = "", sqref = "", sqrefIndexArr = [], valueArr = [];
            var _prohibitInput = (0, method_1.getXmlAttibute)(attrList, "allowBlank", null) !== "1" ? false : true;
            var formulaReg = new RegExp(/<x14:formula1>|<xm:sqref>/g);
            if (formulaReg.test(formulaValue) && (extLst === null || extLst === void 0 ? void 0 : extLst.length) >= 0) {
              operator = (0, method_1.getXmlAttibute)(attrList, "operator", null);
              var peelOffData = (0, method_1.getPeelOffX14)(formulaValue);
              sqref = peelOffData === null || peelOffData === void 0 ? void 0 : peelOffData.sqref;
              sqrefIndexArr = (0, method_1.getMultiSequenceToNum)(sqref);
              valueArr = (0, method_1.getMultiFormulaValue)(peelOffData === null || peelOffData === void 0 ? void 0 : peelOffData.formula);
            } else {
              operator = (0, method_1.getXmlAttibute)(attrList, "operator", null);
              sqref = (0, method_1.getXmlAttibute)(attrList, "sqref", null);
              sqrefIndexArr = (0, method_1.getMultiSequenceToNum)(sqref);
              valueArr = (0, method_1.getMultiFormulaValue)(formulaValue);
            }
            var _type = constant_1.DATA_VERIFICATION_MAP[type];
            var _type2 = null;
            var _value1 = (valueArr === null || valueArr === void 0 ? void 0 : valueArr.length) >= 1 ? valueArr[0] : "";
            var _value2 = (valueArr === null || valueArr === void 0 ? void 0 : valueArr.length) === 2 ? valueArr[1] : "";
            var _hint = (0, method_1.getXmlAttibute)(attrList, "prompt", null);
            var _hintShow = _hint ? true : false;
            var matchType = constant_1.COMMON_TYPE2.includes(_type) ? "common" : _type;
            _type2 = operator ? constant_1.DATA_VERIFICATION_TYPE2_MAP[matchType][operator] : "bw";
            if (_type === "text_content" && ((_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("LEN")) || (_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("len"))) && (_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("=11"))) {
              _type = "validity";
              _type2 = "phone";
            }
            if (_type === "date") {
              var D1900 = new Date(1899, 11, 30, 0, 0, 0);
              _value1 = (0, dayjs_1.default)(D1900).clone().add(Number(_value1), "day").format("YYYY-MM-DD");
              _value2 = (0, dayjs_1.default)(D1900).clone().add(Number(_value2), "day").format("YYYY-MM-DD");
            }
            if (_type === "checkbox" || _type === "dropdown") {
              _type2 = null;
            }
            for (var _i = 0, sqrefIndexArr_1 = sqrefIndexArr; _i < sqrefIndexArr_1.length; _i++) {
              var ref = sqrefIndexArr_1[_i];
              dataVerification[ref] = {
                type: _type,
                type2: _type2,
                value1: _value1,
                value2: _value2,
                checked: false,
                remote: false,
                prohibitInput: _prohibitInput,
                hintShow: _hintShow,
                hintText: _hint
              };
            }
          }
          return dataVerification;
        };
        FortuneSheet2.prototype.generateConfigHyperlinks = function() {
          var _a;
          var rows = this.readXml.getElementsByTagName("hyperlinks/hyperlink", this.sheetFile);
          var hyperlink = {};
          var _loop_1 = function(i2) {
            var row = rows[i2];
            var attrList = row.attributeList;
            var ref = (0, method_1.getXmlAttibute)(attrList, "ref", null), refArr = (0, method_1.getMultiSequenceToNum)(ref), _display = (0, method_1.getXmlAttibute)(attrList, "display", null), _address = (0, method_1.getXmlAttibute)(attrList, "location", null), _tooltip = (0, method_1.getXmlAttibute)(attrList, "tooltip", null);
            var _type = _address ? "internal" : "external";
            if (!_address) {
              var rid_1 = attrList["r:id"];
              var sheetFile = this_1.sheetFile;
              var relationshipList = this_1.readXml.getElementsByTagName("Relationships/Relationship", "xl/worksheets/_rels/".concat(sheetFile.replace(constant_1.worksheetFilePath, ""), ".rels"));
              var findRid = relationshipList === null || relationshipList === void 0 ? void 0 : relationshipList.find(function(e) {
                return e.attributeList["Id"] === rid_1;
              });
              if (findRid) {
                _address = findRid.attributeList["Target"];
                _type = (_a = findRid.attributeList["TargetMode"]) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
              }
            }
            var addressReg = new RegExp(/^.*!R([\d$])+C([\d$])*$/g);
            if (addressReg.test(_address)) {
              _address = (0, method_1.getTransR1C1ToSequence)(_address);
            }
            for (var _i = 0, refArr_1 = refArr; _i < refArr_1.length; _i++) {
              var ref_1 = refArr_1[_i];
              hyperlink[ref_1] = {
                linkAddress: _address,
                linkTooltip: _tooltip || "",
                linkType: _type,
                display: _display || ""
              };
            }
          };
          var this_1 = this;
          for (var i = 0; i < rows.length; i++) {
            _loop_1(i);
          }
          return hyperlink;
        };
        return FortuneSheet2;
      }(FortuneBase_1.FortuneSheetBase)
    );
    exports.FortuneSheet = FortuneSheet;
  }
});

// node_modules/@corbe30/fortune-excel/dist/common/emf.js
var require_emf = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/common/emf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToContext2D = exports.FromEMF = exports.UDOC = void 0;
    exports.UDOC = {};
    exports.UDOC.G = {
      concat: function(p, r) {
        for (var i = 0; i < r.cmds.length; i++)
          p.cmds.push(r.cmds[i]);
        for (var i = 0; i < r.crds.length; i++)
          p.crds.push(r.crds[i]);
      },
      getBB: function(ps) {
        var x0 = 1e99, y0 = 1e99, x1 = -x0, y1 = -y0;
        for (var i = 0; i < ps.length; i += 2) {
          var x = ps[i], y = ps[i + 1];
          if (x < x0)
            x0 = x;
          else if (x > x1)
            x1 = x;
          if (y < y0)
            y0 = y;
          else if (y > y1)
            y1 = y;
        }
        return [x0, y0, x1, y1];
      },
      rectToPath: function(r) {
        return {
          cmds: ["M", "L", "L", "L", "Z"],
          crds: [r[0], r[1], r[2], r[1], r[2], r[3], r[0], r[3]]
        };
      },
      // a inside b
      insideBox: function(a, b) {
        return b[0] <= a[0] && b[1] <= a[1] && a[2] <= b[2] && a[3] <= b[3];
      },
      isBox: function(p, bb) {
        var sameCrd8 = function(pcrd, crds2) {
          for (var o = 0; o < 8; o += 2) {
            var eq = true;
            for (var j = 0; j < 8; j++)
              if (Math.abs(crds2[j] - pcrd[j + o & 7]) >= 2) {
                eq = false;
                break;
              }
            if (eq)
              return true;
          }
          return false;
        };
        if (p.cmds.length > 10)
          return false;
        var cmds = p.cmds.join(""), crds = p.crds;
        var sameRect = false;
        if (cmds == "MLLLZ" && crds.length == 8 || cmds == "MLLLLZ" && crds.length == 10) {
          if (crds.length == 10)
            crds = crds.slice(0, 8);
          var x0 = bb[0], y0 = bb[1], x1 = bb[2], y1 = bb[3];
          if (!sameRect)
            sameRect = sameCrd8(crds, [x0, y0, x1, y0, x1, y1, x0, y1]);
          if (!sameRect)
            sameRect = sameCrd8(crds, [x0, y1, x1, y1, x1, y0, x0, y0]);
        }
        return sameRect;
      },
      boxArea: function(a) {
        var w = a[2] - a[0], h = a[3] - a[1];
        return w * h;
      },
      newPath: function(gst) {
        gst.pth = { cmds: [], crds: [] };
      },
      moveTo: function(gst, x, y) {
        var p = exports.UDOC.M.multPoint(gst.ctm, [x, y]);
        gst.pth.cmds.push("M");
        gst.pth.crds.push(p[0], p[1]);
        gst.cpos = p;
      },
      lineTo: function(gst, x, y) {
        var p = exports.UDOC.M.multPoint(gst.ctm, [x, y]);
        if (gst.cpos[0] == p[0] && gst.cpos[1] == p[1])
          return;
        gst.pth.cmds.push("L");
        gst.pth.crds.push(p[0], p[1]);
        gst.cpos = p;
      },
      curveTo: function(gst, x1, y1, x2, y2, x3, y3) {
        var p;
        p = exports.UDOC.M.multPoint(gst.ctm, [x1, y1]);
        x1 = p[0];
        y1 = p[1];
        p = exports.UDOC.M.multPoint(gst.ctm, [x2, y2]);
        x2 = p[0];
        y2 = p[1];
        p = exports.UDOC.M.multPoint(gst.ctm, [x3, y3]);
        x3 = p[0];
        y3 = p[1];
        gst.cpos = p;
        gst.pth.cmds.push("C");
        gst.pth.crds.push(x1, y1, x2, y2, x3, y3);
      },
      closePath: function(gst) {
        gst.pth.cmds.push("Z");
      },
      arc: function(gst, x, y, r, a0, a1, neg) {
        if (neg)
          while (a1 > a0)
            a1 -= 2 * Math.PI;
        else
          while (a1 < a0)
            a1 += 2 * Math.PI;
        var th = (a1 - a0) / 4;
        var x0 = Math.cos(th / 2), y0 = -Math.sin(th / 2);
        var x1 = (4 - x0) / 3, y1 = y0 == 0 ? y0 : (1 - x0) * (3 - x0) / (3 * y0);
        var x2 = x1, y2 = -y1;
        var x3 = x0, y3 = -y0;
        var p0 = [x0, y0], p1 = [x1, y1], p2 = [x2, y2], p3 = [x3, y3];
        var pth = {
          cmds: [gst.pth.cmds.length == 0 ? "M" : "L", "C", "C", "C", "C"],
          crds: [x0, y0, x1, y1, x2, y2, x3, y3]
        };
        var rot = [1, 0, 0, 1, 0, 0];
        exports.UDOC.M.rotate(rot, -th);
        for (var i = 0; i < 3; i++) {
          p1 = exports.UDOC.M.multPoint(rot, p1);
          p2 = exports.UDOC.M.multPoint(rot, p2);
          p3 = exports.UDOC.M.multPoint(rot, p3);
          pth.crds.push(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
        }
        var sc = [r, 0, 0, r, x, y];
        exports.UDOC.M.rotate(rot, -a0 + th / 2);
        exports.UDOC.M.concat(rot, sc);
        exports.UDOC.M.multArray(rot, pth.crds);
        exports.UDOC.M.multArray(gst.ctm, pth.crds);
        exports.UDOC.G.concat(gst.pth, pth);
        var y = pth.crds.pop();
        x = pth.crds.pop();
        gst.cpos = [x, y];
      },
      toPoly: function(p) {
        if (p.cmds[0] != "M" || p.cmds[p.cmds.length - 1] != "Z")
          return null;
        for (var i = 1; i < p.cmds.length - 1; i++)
          if (p.cmds[i] != "L")
            return null;
        var out = [], cl = p.crds.length;
        if (p.crds[0] == p.crds[cl - 2] && p.crds[1] == p.crds[cl - 1])
          cl -= 2;
        for (var i = 0; i < cl; i += 2)
          out.push([p.crds[i], p.crds[i + 1]]);
        if (exports.UDOC.G.polyArea(p.crds) < 0)
          out.reverse();
        return out;
      },
      fromPoly: function(p) {
        var o = { cmds: [], crds: [] };
        for (var i = 0; i < p.length; i++) {
          o.crds.push(p[i][0], p[i][1]);
          o.cmds.push(i == 0 ? "M" : "L");
        }
        o.cmds.push("Z");
        return o;
      },
      polyArea: function(p) {
        if (p.length < 6)
          return 0;
        var l = p.length - 2;
        var sum = (p[0] - p[l]) * (p[l + 1] + p[1]);
        for (var i = 0; i < l; i += 2)
          sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
        return -sum * 0.5;
      },
      polyClip: function(p0, p1) {
        var cp1, cp2, s, e;
        var inside = function(p) {
          return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);
        };
        var isc = function() {
          var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]], dp = [s[0] - e[0], s[1] - e[1]], n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0], n2 = s[0] * e[1] - s[1] * e[0], n3 = 1 / (dc[0] * dp[1] - dc[1] * dp[0]);
          return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];
        };
        var out = p0;
        cp1 = p1[p1.length - 1];
        for (var j in p1) {
          var cp2 = p1[j];
          var inp = out;
          out = [];
          s = inp[inp.length - 1];
          for (var i in inp) {
            var e = inp[i];
            if (inside(e)) {
              if (!inside(s)) {
                out.push(isc());
              }
              out.push(e);
            } else if (inside(s)) {
              out.push(isc());
            }
            s = e;
          }
          cp1 = cp2;
        }
        return out;
      }
    };
    exports.UDOC.M = {
      getScale: function(m) {
        return Math.sqrt(Math.abs(m[0] * m[3] - m[1] * m[2]));
      },
      translate: function(m, x, y) {
        exports.UDOC.M.concat(m, [1, 0, 0, 1, x, y]);
      },
      rotate: function(m, a) {
        exports.UDOC.M.concat(m, [
          Math.cos(a),
          -Math.sin(a),
          Math.sin(a),
          Math.cos(a),
          0,
          0
        ]);
      },
      scale: function(m, x, y) {
        exports.UDOC.M.concat(m, [x, 0, 0, y, 0, 0]);
      },
      concat: function(m, w) {
        var a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
        m[0] = a * w[0] + b * w[2];
        m[1] = a * w[1] + b * w[3];
        m[2] = c * w[0] + d * w[2];
        m[3] = c * w[1] + d * w[3];
        m[4] = tx * w[0] + ty * w[2] + w[4];
        m[5] = tx * w[1] + ty * w[3] + w[5];
      },
      invert: function(m) {
        var a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5], adbc = a * d - b * c;
        m[0] = d / adbc;
        m[1] = -b / adbc;
        m[2] = -c / adbc;
        m[3] = a / adbc;
        m[4] = (c * ty - d * tx) / adbc;
        m[5] = (b * tx - a * ty) / adbc;
      },
      multPoint: function(m, p) {
        var x = p[0], y = p[1];
        return [x * m[0] + y * m[2] + m[4], x * m[1] + y * m[3] + m[5]];
      },
      multArray: function(m, a) {
        for (var i = 0; i < a.length; i += 2) {
          var x = a[i], y = a[i + 1];
          a[i] = x * m[0] + y * m[2] + m[4];
          a[i + 1] = x * m[1] + y * m[3] + m[5];
        }
      }
    };
    exports.UDOC.C = {
      srgbGamma: function(x) {
        return x < 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
      },
      cmykToRgb: function(clr) {
        var c = clr[0], m = clr[1], y = clr[2], k = clr[3];
        var r = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
        var g = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
        var b = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
        return [
          Math.max(0, Math.min(1, r / 255)),
          Math.max(0, Math.min(1, g / 255)),
          Math.max(0, Math.min(1, b / 255))
        ];
      },
      labToRgb: function(lab) {
        var k = 903.3, e = 8856e-6, L = lab[0], a = lab[1], b = lab[2];
        var fy = (L + 16) / 116, fy3 = fy * fy * fy;
        var fz = fy - b / 200, fz3 = fz * fz * fz;
        var fx = a / 500 + fy, fx3 = fx * fx * fx;
        var zr = fz3 > e ? fz3 : (116 * fz - 16) / k;
        var yr = fy3 > e ? fy3 : (116 * fy - 16) / k;
        var xr = fx3 > e ? fx3 : (116 * fx - 16) / k;
        var X = xr * 96.72, Y = yr * 100, Z = zr * 81.427, xyz = [X / 100, Y / 100, Z / 100];
        var x2s = [
          3.1338561,
          -1.6168667,
          -0.4906146,
          -0.9787684,
          1.9161415,
          0.033454,
          0.0719453,
          -0.2289914,
          1.4052427
        ];
        var rgb = [
          x2s[0] * xyz[0] + x2s[1] * xyz[1] + x2s[2] * xyz[2],
          x2s[3] * xyz[0] + x2s[4] * xyz[1] + x2s[5] * xyz[2],
          x2s[6] * xyz[0] + x2s[7] * xyz[1] + x2s[8] * xyz[2]
        ];
        for (var i = 0; i < 3; i++)
          rgb[i] = Math.max(0, Math.min(1, exports.UDOC.C.srgbGamma(rgb[i])));
        return rgb;
      }
    };
    exports.UDOC.getState = function(crds) {
      return {
        font: exports.UDOC.getFont(),
        dd: { flat: 1 },
        // device-dependent
        space: "/DeviceGray",
        // fill
        ca: 1,
        colr: [0, 0, 0],
        sspace: "/DeviceGray",
        // stroke
        CA: 1,
        COLR: [0, 0, 0],
        bmode: "/Normal",
        SA: false,
        OPM: 0,
        AIS: false,
        OP: false,
        op: false,
        SMask: "/None",
        lwidth: 1,
        lcap: 0,
        ljoin: 0,
        mlimit: 10,
        SM: 0.1,
        doff: 0,
        dash: [],
        ctm: [1, 0, 0, 1, 0, 0],
        cpos: [0, 0],
        pth: { cmds: [], crds: [] },
        cpth: crds ? exports.UDOC.G.rectToPath(crds) : null
        // clipping path
      };
    };
    exports.UDOC.getFont = function() {
      return {
        Tc: 0,
        // character spacing
        Tw: 0,
        // word spacing
        Th: 100,
        // horizontal scale
        Tl: 0,
        // leading
        Tf: "Helvetica-Bold",
        Tfs: 1,
        // font size
        Tmode: 0,
        // rendering mode
        Trise: 0,
        // rise
        Tk: 0,
        // knockout
        Tal: 0,
        // align, 0: left, 1: right, 2: center
        Tun: 0,
        // 0: no, 1: underline
        Tm: [1, 0, 0, 1, 0, 0],
        Tlm: [1, 0, 0, 1, 0, 0],
        Trm: [1, 0, 0, 1, 0, 0]
      };
    };
    var FromEMF = function() {
    };
    exports.FromEMF = FromEMF;
    exports.FromEMF.Parse = function(buff, genv) {
      buff = new Uint8Array(buff);
      var off = 0;
      var prms = {
        fill: false,
        strk: false,
        bb: [0, 0, 1, 1],
        wbb: [0, 0, 1, 1],
        fnt: { nam: "Arial", hgh: 25, und: false, orn: 0 },
        tclr: [0, 0, 0],
        talg: 0
      }, gst, tab = [], sts = [];
      var rI = exports.FromEMF.B.readShort, rU = exports.FromEMF.B.readUshort, rI32 = exports.FromEMF.B.readInt, rU32 = exports.FromEMF.B.readUint, rF32 = exports.FromEMF.B.readFloat;
      var opn = 0;
      while (true) {
        var fnc = rU32(buff, off);
        off += 4;
        var fnm = exports.FromEMF.K[fnc];
        var siz = rU32(buff, off);
        off += 4;
        var loff = off;
        var obj = null, oid = 0;
        if (false) {
        } else if (fnm == "EOF") {
          break;
        } else if (fnm == "HEADER") {
          prms.bb = exports.FromEMF._readBox(buff, loff);
          loff += 16;
          genv.StartPage(prms.bb[0], prms.bb[1], prms.bb[2], prms.bb[3]);
          gst = exports.UDOC.getState(prms.bb);
        } else if (fnm == "SAVEDC")
          sts.push(JSON.stringify(gst), JSON.stringify(prms));
        else if (fnm == "RESTOREDC") {
          var dif = rI32(buff, loff);
          loff += 4;
          while (dif < -1) {
            sts.pop();
            sts.pop();
          }
          prms = JSON.parse(sts.pop());
          gst = JSON.parse(sts.pop());
        } else if (fnm == "SELECTCLIPPATH") {
          gst.cpth = JSON.parse(JSON.stringify(gst.pth));
        } else if ([
          "SETMAPMODE",
          "SETPOLYFILLMODE",
          "SETBKMODE",
          "SETICMMODE",
          "SETROP2",
          "EXTSELECTCLIPRGN"
        ].indexOf(fnm) != -1) {
        } else if (fnm == "SETMITERLIMIT")
          gst.mlimit = rU32(buff, loff);
        else if (fnm == "SETTEXTCOLOR")
          prms.tclr = [
            buff[loff] / 255,
            buff[loff + 1] / 255,
            buff[loff + 2] / 255
          ];
        else if (fnm == "SETTEXTALIGN")
          prms.talg = rU32(buff, loff);
        else if (fnm == "SETVIEWPORTEXTEX" || fnm == "SETVIEWPORTORGEX") {
          if (prms.vbb == null)
            prms.vbb = [];
          var coff = fnm == "SETVIEWPORTORGEX" ? 0 : 2;
          prms.vbb[coff] = rI32(buff, loff);
          loff += 4;
          prms.vbb[coff + 1] = rI32(buff, loff);
          loff += 4;
          if (fnm == "SETVIEWPORTEXTEX")
            exports.FromEMF._updateCtm(prms, gst);
        } else if (fnm == "SETWINDOWEXTEX" || fnm == "SETWINDOWORGEX") {
          var coff = fnm == "SETWINDOWORGEX" ? 0 : 2;
          prms.wbb[coff] = rI32(buff, loff);
          loff += 4;
          prms.wbb[coff + 1] = rI32(buff, loff);
          loff += 4;
          if (fnm == "SETWINDOWEXTEX")
            exports.FromEMF._updateCtm(prms, gst);
        } else if (fnm == "COMMENT") {
          var ds = rU32(buff, loff);
          loff += 4;
        } else if (fnm == "SELECTOBJECT") {
          var ind = rU32(buff, loff);
          loff += 4;
          if (ind == 2147483648) {
            prms.fill = true;
            gst.colr = [1, 1, 1];
          } else if (ind == 2147483653) {
            prms.fill = false;
          } else if (ind == 2147483655) {
            prms.strk = true;
            prms.lwidth = 1;
            gst.COLR = [0, 0, 0];
          } else if (ind == 2147483656) {
            prms.strk = false;
          } else if (ind == 2147483661) {
          } else if (ind == 2147483662) {
          } else {
            var co = tab[ind];
            if (co.t == "b") {
              prms.fill = co.stl != 1;
              if (co.stl == 0) {
              } else if (co.stl == 1) {
              } else
                throw co.stl + " e";
              gst.colr = co.clr;
            } else if (co.t == "p") {
              prms.strk = co.stl != 5;
              gst.lwidth = co.wid;
              gst.COLR = co.clr;
            } else if (co.t == "f") {
              prms.fnt = co;
              gst.font.Tf = co.nam;
              gst.font.Tfs = Math.abs(co.hgh);
              gst.font.Tun = co.und;
            } else
              throw "e";
          }
        } else if (fnm == "DELETEOBJECT") {
          var ind = rU32(buff, loff);
          loff += 4;
          if (tab[ind] != null)
            tab[ind] = null;
          else
            throw "e";
        } else if (fnm == "CREATEBRUSHINDIRECT") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = { t: "b" };
          obj.stl = rU32(buff, loff);
          loff += 4;
          obj.clr = [buff[loff] / 255, buff[loff + 1] / 255, buff[loff + 2] / 255];
          loff += 4;
          obj.htc = rU32(buff, loff);
          loff += 4;
        } else if (fnm == "CREATEPEN" || fnm == "EXTCREATEPEN") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = { t: "p" };
          if (fnm == "EXTCREATEPEN") {
            loff += 16;
            obj.stl = rU32(buff, loff);
            loff += 4;
            obj.wid = rU32(buff, loff);
            loff += 4;
            loff += 4;
          } else {
            obj.stl = rU32(buff, loff);
            loff += 4;
            obj.wid = rU32(buff, loff);
            loff += 4;
            loff += 4;
          }
          obj.clr = [buff[loff] / 255, buff[loff + 1] / 255, buff[loff + 2] / 255];
          loff += 4;
        } else if (fnm == "EXTCREATEFONTINDIRECTW") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = { t: "f", nam: "" };
          obj.hgh = rI32(buff, loff);
          loff += 4;
          loff += 4 * 2;
          obj.orn = rI32(buff, loff) / 10;
          loff += 4;
          var wgh = rU32(buff, loff);
          loff += 4;
          obj.und = buff[loff + 1];
          obj.stk = buff[loff + 2];
          loff += 4 * 2;
          while (rU(buff, loff) != 0) {
            obj.nam += String.fromCharCode(rU(buff, loff));
            loff += 2;
          }
          if (wgh > 500)
            obj.nam += "-Bold";
        } else if (fnm == "EXTTEXTOUTW") {
          loff += 16;
          var mod = rU32(buff, loff);
          loff += 4;
          var scx = rF32(buff, loff);
          loff += 4;
          var scy = rF32(buff, loff);
          loff += 4;
          var rfx = rI32(buff, loff);
          loff += 4;
          var rfy = rI32(buff, loff);
          loff += 4;
          gst.font.Tm = [1, 0, 0, -1, 0, 0];
          exports.UDOC.M.rotate(gst.font.Tm, prms.fnt.orn * Math.PI / 180);
          exports.UDOC.M.translate(gst.font.Tm, rfx, rfy);
          var alg = prms.talg;
          if ((alg & 6) == 6)
            gst.font.Tal = 2;
          else if ((alg & 7) == 0)
            gst.font.Tal = 0;
          else
            throw alg + " e";
          if ((alg & 24) == 24) {
          } else if ((alg & 24) == 0)
            exports.UDOC.M.translate(gst.font.Tm, 0, gst.font.Tfs);
          else
            throw "e";
          var crs = rU32(buff, loff);
          loff += 4;
          var ofs = rU32(buff, loff);
          loff += 4;
          var ops = rU32(buff, loff);
          loff += 4;
          loff += 16;
          var ofD = rU32(buff, loff);
          loff += 4;
          ofs += off - 8;
          var str = "";
          for (var i = 0; i < crs; i++) {
            var cc = rU(buff, ofs + i * 2);
            str += String.fromCharCode(cc);
          }
          var oclr = gst.colr;
          gst.colr = prms.tclr;
          genv.PutText(gst, str, str.length * gst.font.Tfs * 0.5);
          gst.colr = oclr;
        } else if (fnm == "BEGINPATH") {
          exports.UDOC.G.newPath(gst);
        } else if (fnm == "ENDPATH") {
        } else if (fnm == "CLOSEFIGURE")
          exports.UDOC.G.closePath(gst);
        else if (fnm == "MOVETOEX") {
          exports.UDOC.G.moveTo(gst, rI32(buff, loff), rI32(buff, loff + 4));
        } else if (fnm == "LINETO") {
          if (gst.pth.cmds.length == 0) {
            var im = gst.ctm.slice(0);
            exports.UDOC.M.invert(im);
            var p = exports.UDOC.M.multPoint(im, gst.cpos);
            exports.UDOC.G.moveTo(gst, p[0], p[1]);
          }
          exports.UDOC.G.lineTo(gst, rI32(buff, loff), rI32(buff, loff + 4));
        } else if (fnm == "POLYGON" || fnm == "POLYGON16" || fnm == "POLYLINE" || fnm == "POLYLINE16" || fnm == "POLYLINETO" || fnm == "POLYLINETO16") {
          loff += 16;
          var ndf = fnm.startsWith("POLYGON"), isTo = fnm.indexOf("TO") != -1;
          var cnt = rU32(buff, loff);
          loff += 4;
          if (!isTo)
            exports.UDOC.G.newPath(gst);
          loff = exports.FromEMF._drawPoly(buff, loff, cnt, gst, fnm.endsWith("16") ? 2 : 4, ndf, isTo);
          if (!isTo)
            exports.FromEMF._draw(genv, gst, prms, ndf);
        } else if (fnm == "POLYPOLYGON16") {
          loff += 16;
          var ndf = fnm.startsWith("POLYPOLYGON"), isTo = fnm.indexOf("TO") != -1;
          var nop = rU32(buff, loff);
          loff += 4;
          loff += 4;
          var pi = loff;
          loff += nop * 4;
          if (!isTo)
            exports.UDOC.G.newPath(gst);
          for (var i = 0; i < nop; i++) {
            var ppp = rU(buff, pi + i * 4);
            loff = exports.FromEMF._drawPoly(buff, loff, ppp, gst, fnm.endsWith("16") ? 2 : 4, ndf, isTo);
          }
          if (!isTo)
            exports.FromEMF._draw(genv, gst, prms, ndf);
        } else if (fnm == "POLYBEZIER" || fnm == "POLYBEZIER16" || fnm == "POLYBEZIERTO" || fnm == "POLYBEZIERTO16") {
          loff += 16;
          var is16 = fnm.endsWith("16"), rC = is16 ? rI : rI32, nl = is16 ? 2 : 4;
          var cnt = rU32(buff, loff);
          loff += 4;
          if (fnm.indexOf("TO") == -1) {
            exports.UDOC.G.moveTo(gst, rC(buff, loff), rC(buff, loff + nl));
            loff += 2 * nl;
            cnt--;
          }
          while (cnt > 0) {
            exports.UDOC.G.curveTo(gst, rC(buff, loff), rC(buff, loff + nl), rC(buff, loff + 2 * nl), rC(buff, loff + 3 * nl), rC(buff, loff + 4 * nl), rC(buff, loff + 5 * nl));
            loff += 6 * nl;
            cnt -= 3;
          }
        } else if (fnm == "RECTANGLE" || fnm == "ELLIPSE") {
          exports.UDOC.G.newPath(gst);
          var bx = exports.FromEMF._readBox(buff, loff);
          if (fnm == "RECTANGLE") {
            exports.UDOC.G.moveTo(gst, bx[0], bx[1]);
            exports.UDOC.G.lineTo(gst, bx[2], bx[1]);
            exports.UDOC.G.lineTo(gst, bx[2], bx[3]);
            exports.UDOC.G.lineTo(gst, bx[0], bx[3]);
          } else {
            var x = (bx[0] + bx[2]) / 2, y = (bx[1] + bx[3]) / 2;
            exports.UDOC.G.arc(gst, x, y, (bx[2] - bx[0]) / 2, 0, 2 * Math.PI, false);
          }
          exports.UDOC.G.closePath(gst);
          exports.FromEMF._draw(genv, gst, prms, true);
        } else if (fnm == "FILLPATH")
          genv.Fill(gst, false);
        else if (fnm == "STROKEPATH")
          genv.Stroke(gst);
        else if (fnm == "STROKEANDFILLPATH") {
          genv.Fill(gst, false);
          genv.Stroke(gst);
        } else if (fnm == "SETWORLDTRANSFORM" || fnm == "MODIFYWORLDTRANSFORM") {
          var mat = [];
          for (var i = 0; i < 6; i++)
            mat.push(rF32(buff, loff + i * 4));
          loff += 24;
          if (fnm == "SETWORLDTRANSFORM")
            gst.ctm = mat;
          else {
            var mod = rU32(buff, loff);
            loff += 4;
            if (mod == 2) {
              var om = gst.ctm;
              gst.ctm = mat;
              exports.UDOC.M.concat(gst.ctm, om);
            } else
              throw "e";
          }
        } else if (fnm == "SETSTRETCHBLTMODE") {
          var sm = rU32(buff, loff);
          loff += 4;
        } else if (fnm == "STRETCHDIBITS") {
          var bx = exports.FromEMF._readBox(buff, loff);
          loff += 16;
          var xD = rI32(buff, loff);
          loff += 4;
          var yD = rI32(buff, loff);
          loff += 4;
          var xS = rI32(buff, loff);
          loff += 4;
          var yS = rI32(buff, loff);
          loff += 4;
          var wS = rI32(buff, loff);
          loff += 4;
          var hS = rI32(buff, loff);
          loff += 4;
          var ofH = rU32(buff, loff) + off - 8;
          loff += 4;
          var szH = rU32(buff, loff);
          loff += 4;
          var ofB = rU32(buff, loff) + off - 8;
          loff += 4;
          var szB = rU32(buff, loff);
          loff += 4;
          var usg = rU32(buff, loff);
          loff += 4;
          if (usg != 0)
            throw "e";
          var bop = rU32(buff, loff);
          loff += 4;
          var wD = rI32(buff, loff);
          loff += 4;
          var hD = rI32(buff, loff);
          loff += 4;
          var hl = rU32(buff, ofH);
          ofH += 4;
          var w = rU32(buff, ofH);
          ofH += 4;
          var h = rU32(buff, ofH);
          ofH += 4;
          if (w != wS || h != hS)
            throw "e";
          var ps = rU(buff, ofH);
          ofH += 2;
          var bc = rU(buff, ofH);
          ofH += 2;
          if (bc != 8 && bc != 24 && bc != 32)
            throw bc + " e";
          var cpr = rU32(buff, ofH);
          ofH += 4;
          if (cpr != 0)
            throw cpr + " e";
          var sz = rU32(buff, ofH);
          ofH += 4;
          var xpm = rU32(buff, ofH);
          ofH += 4;
          var ypm = rU32(buff, ofH);
          ofH += 4;
          var cu = rU32(buff, ofH);
          ofH += 4;
          var ci = rU32(buff, ofH);
          ofH += 4;
          var rl = Math.floor((w * ps * bc + 31 & ~31) / 8);
          var img = new Uint8Array(w * h * 4);
          if (bc == 8) {
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2, ind = buff[ofB + (h - 1 - y) * rl + x] << 2;
                img[qi] = buff[ofH + ind + 2];
                img[qi + 1] = buff[ofH + ind + 1];
                img[qi + 2] = buff[ofH + ind + 0];
                img[qi + 3] = 255;
              }
          }
          if (bc == 24) {
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2, ti = ofB + (h - 1 - y) * rl + x * 3;
                img[qi] = buff[ti + 2];
                img[qi + 1] = buff[ti + 1];
                img[qi + 2] = buff[ti + 0];
                img[qi + 3] = 255;
              }
          }
          if (bc == 32) {
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2, ti = ofB + (h - 1 - y) * rl + x * 4;
                img[qi] = buff[ti + 2];
                img[qi + 1] = buff[ti + 1];
                img[qi + 2] = buff[ti + 0];
                img[qi + 3] = buff[ti + 3];
              }
          }
          var ctm = gst.ctm.slice(0);
          gst.ctm = [1, 0, 0, 1, 0, 0];
          exports.UDOC.M.scale(gst.ctm, wD, -hD);
          exports.UDOC.M.translate(gst.ctm, xD, yD + hD);
          exports.UDOC.M.concat(gst.ctm, ctm);
          genv.PutImage(gst, img, w, h);
          gst.ctm = ctm;
        } else {
          console.log(fnm, siz);
        }
        if (obj != null)
          tab[oid] = obj;
        off += siz - 8;
      }
      genv.ShowPage();
      genv.Done();
    };
    exports.FromEMF._readBox = function(buff, off) {
      var b = [];
      for (var i = 0; i < 4; i++)
        b[i] = exports.FromEMF.B.readInt(buff, off + i * 4);
      return b;
    };
    exports.FromEMF._updateCtm = function(prms, gst) {
      var mat = [1, 0, 0, 1, 0, 0];
      var wbb = prms.wbb, bb = prms.bb, vbb = prms.vbb && prms.vbb.length == 4 ? prms.vbb : prms.bb;
      exports.UDOC.M.translate(mat, -wbb[0], -wbb[1]);
      exports.UDOC.M.scale(mat, 1 / wbb[2], 1 / wbb[3]);
      exports.UDOC.M.scale(mat, vbb[2], vbb[3]);
      gst.ctm = mat;
    };
    exports.FromEMF._draw = function(genv, gst, prms, needFill) {
      if (prms.fill && needFill)
        genv.Fill(gst, false);
      if (prms.strk && gst.lwidth != 0)
        genv.Stroke(gst);
    };
    exports.FromEMF._drawPoly = function(buff, off, ppp, gst, nl, clos, justLine) {
      var rS = nl == 2 ? exports.FromEMF.B.readShort : exports.FromEMF.B.readInt;
      for (var j = 0; j < ppp; j++) {
        var px = rS(buff, off);
        off += nl;
        var py = rS(buff, off);
        off += nl;
        if (j == 0 && !justLine)
          exports.UDOC.G.moveTo(gst, px, py);
        else
          exports.UDOC.G.lineTo(gst, px, py);
      }
      if (clos)
        exports.UDOC.G.closePath(gst);
      return off;
    };
    exports.FromEMF.B = {
      uint8: new Uint8Array(4),
      readShort: function(buff, p) {
        var u8 = exports.FromEMF.B.uint8;
        u8[0] = buff[p];
        u8[1] = buff[p + 1];
        return exports.FromEMF.B.int16[0];
      },
      readUshort: function(buff, p) {
        var u8 = exports.FromEMF.B.uint8;
        u8[0] = buff[p];
        u8[1] = buff[p + 1];
        return exports.FromEMF.B.uint16[0];
      },
      readInt: function(buff, p) {
        var u8 = exports.FromEMF.B.uint8;
        u8[0] = buff[p];
        u8[1] = buff[p + 1];
        u8[2] = buff[p + 2];
        u8[3] = buff[p + 3];
        return exports.FromEMF.B.int32[0];
      },
      readUint: function(buff, p) {
        var u8 = exports.FromEMF.B.uint8;
        u8[0] = buff[p];
        u8[1] = buff[p + 1];
        u8[2] = buff[p + 2];
        u8[3] = buff[p + 3];
        return exports.FromEMF.B.uint32[0];
      },
      readFloat: function(buff, p) {
        var u8 = exports.FromEMF.B.uint8;
        u8[0] = buff[p];
        u8[1] = buff[p + 1];
        u8[2] = buff[p + 2];
        u8[3] = buff[p + 3];
        return exports.FromEMF.B.flot32[0];
      },
      readASCII: function(buff, p, l) {
        var s = "";
        for (var i = 0; i < l; i++)
          s += String.fromCharCode(buff[p + i]);
        return s;
      }
    };
    exports.FromEMF.B.int16 = new Int16Array(exports.FromEMF.B.uint8.buffer);
    exports.FromEMF.B.uint16 = new Uint16Array(exports.FromEMF.B.uint8.buffer);
    exports.FromEMF.B.int32 = new Int32Array(exports.FromEMF.B.uint8.buffer);
    exports.FromEMF.B.uint32 = new Uint32Array(exports.FromEMF.B.uint8.buffer);
    exports.FromEMF.B.flot32 = new Float32Array(exports.FromEMF.B.uint8.buffer);
    exports.FromEMF.C = {
      EMR_HEADER: 1,
      EMR_POLYBEZIER: 2,
      EMR_POLYGON: 3,
      EMR_POLYLINE: 4,
      EMR_POLYBEZIERTO: 5,
      EMR_POLYLINETO: 6,
      EMR_POLYPOLYLINE: 7,
      EMR_POLYPOLYGON: 8,
      EMR_SETWINDOWEXTEX: 9,
      EMR_SETWINDOWORGEX: 10,
      EMR_SETVIEWPORTEXTEX: 11,
      EMR_SETVIEWPORTORGEX: 12,
      EMR_SETBRUSHORGEX: 13,
      EMR_EOF: 14,
      EMR_SETPIXELV: 15,
      EMR_SETMAPPERFLAGS: 16,
      EMR_SETMAPMODE: 17,
      EMR_SETBKMODE: 18,
      EMR_SETPOLYFILLMODE: 19,
      EMR_SETROP2: 20,
      EMR_SETSTRETCHBLTMODE: 21,
      EMR_SETTEXTALIGN: 22,
      EMR_SETCOLORADJUSTMENT: 23,
      EMR_SETTEXTCOLOR: 24,
      EMR_SETBKCOLOR: 25,
      EMR_OFFSETCLIPRGN: 26,
      EMR_MOVETOEX: 27,
      EMR_SETMETARGN: 28,
      EMR_EXCLUDECLIPRECT: 29,
      EMR_INTERSECTCLIPRECT: 30,
      EMR_SCALEVIEWPORTEXTEX: 31,
      EMR_SCALEWINDOWEXTEX: 32,
      EMR_SAVEDC: 33,
      EMR_RESTOREDC: 34,
      EMR_SETWORLDTRANSFORM: 35,
      EMR_MODIFYWORLDTRANSFORM: 36,
      EMR_SELECTOBJECT: 37,
      EMR_CREATEPEN: 38,
      EMR_CREATEBRUSHINDIRECT: 39,
      EMR_DELETEOBJECT: 40,
      EMR_ANGLEARC: 41,
      EMR_ELLIPSE: 42,
      EMR_RECTANGLE: 43,
      EMR_ROUNDRECT: 44,
      EMR_ARC: 45,
      EMR_CHORD: 46,
      EMR_PIE: 47,
      EMR_SELECTPALETTE: 48,
      EMR_CREATEPALETTE: 49,
      EMR_SETPALETTEENTRIES: 50,
      EMR_RESIZEPALETTE: 51,
      EMR_REALIZEPALETTE: 52,
      EMR_EXTFLOODFILL: 53,
      EMR_LINETO: 54,
      EMR_ARCTO: 55,
      EMR_POLYDRAW: 56,
      EMR_SETARCDIRECTION: 57,
      EMR_SETMITERLIMIT: 58,
      EMR_BEGINPATH: 59,
      EMR_ENDPATH: 60,
      EMR_CLOSEFIGURE: 61,
      EMR_FILLPATH: 62,
      EMR_STROKEANDFILLPATH: 63,
      EMR_STROKEPATH: 64,
      EMR_FLATTENPATH: 65,
      EMR_WIDENPATH: 66,
      EMR_SELECTCLIPPATH: 67,
      EMR_ABORTPATH: 68,
      EMR_COMMENT: 70,
      EMR_FILLRGN: 71,
      EMR_FRAMERGN: 72,
      EMR_INVERTRGN: 73,
      EMR_PAINTRGN: 74,
      EMR_EXTSELECTCLIPRGN: 75,
      EMR_BITBLT: 76,
      EMR_STRETCHBLT: 77,
      EMR_MASKBLT: 78,
      EMR_PLGBLT: 79,
      EMR_SETDIBITSTODEVICE: 80,
      EMR_STRETCHDIBITS: 81,
      EMR_EXTCREATEFONTINDIRECTW: 82,
      EMR_EXTTEXTOUTA: 83,
      EMR_EXTTEXTOUTW: 84,
      EMR_POLYBEZIER16: 85,
      EMR_POLYGON16: 86,
      EMR_POLYLINE16: 87,
      EMR_POLYBEZIERTO16: 88,
      EMR_POLYLINETO16: 89,
      EMR_POLYPOLYLINE16: 90,
      EMR_POLYPOLYGON16: 91,
      EMR_POLYDRAW16: 92,
      EMR_CREATEMONOBRUSH: 93,
      EMR_CREATEDIBPATTERNBRUSHPT: 94,
      EMR_EXTCREATEPEN: 95,
      EMR_POLYTEXTOUTA: 96,
      EMR_POLYTEXTOUTW: 97,
      EMR_SETICMMODE: 98,
      EMR_CREATECOLORSPACE: 99,
      EMR_SETCOLORSPACE: 100,
      EMR_DELETECOLORSPACE: 101,
      EMR_GLSRECORD: 102,
      EMR_GLSBOUNDEDRECORD: 103,
      EMR_PIXELFORMAT: 104,
      EMR_DRAWESCAPE: 105,
      EMR_EXTESCAPE: 106,
      EMR_SMALLTEXTOUT: 108,
      EMR_FORCEUFIMAPPING: 109,
      EMR_NAMEDESCAPE: 110,
      EMR_COLORCORRECTPALETTE: 111,
      EMR_SETICMPROFILEA: 112,
      EMR_SETICMPROFILEW: 113,
      EMR_ALPHABLEND: 114,
      EMR_SETLAYOUT: 115,
      EMR_TRANSPARENTBLT: 116,
      EMR_GRADIENTFILL: 118,
      EMR_SETLINKEDUFIS: 119,
      EMR_SETTEXTJUSTIFICATION: 120,
      EMR_COLORMATCHTOTARGETW: 121,
      EMR_CREATECOLORSPACEW: 122
    };
    exports.FromEMF.K = [];
    var ToContext2D = function(needPage, scale) {
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.bb = null;
      this.currPage = 0;
      this.needPage = needPage;
      this.scale = scale;
    };
    exports.ToContext2D = ToContext2D;
    exports.ToContext2D.prototype.StartPage = function(x, y, w, h) {
      if (this.currPage != this.needPage)
        return;
      this.bb = [x, y, w, h];
      var scl = this.scale, dpr = window.devicePixelRatio;
      var cnv = this.canvas, ctx = this.ctx;
      cnv.width = Math.round(w * scl);
      cnv.height = Math.round(h * scl);
      ctx.translate(0, h * scl);
      ctx.scale(scl, -scl);
      cnv.setAttribute("style", "border:1px solid; width:" + cnv.width / dpr + "px; height:" + cnv.height / dpr + "px");
    };
    exports.ToContext2D.prototype.Fill = function(gst, evenOdd) {
      if (this.currPage != this.needPage)
        return;
      var ctx = this.ctx;
      ctx.beginPath();
      this._setStyle(gst, ctx);
      this._draw(gst.pth, ctx);
      ctx.fill();
    };
    exports.ToContext2D.prototype.Stroke = function(gst) {
      if (this.currPage != this.needPage)
        return;
      var ctx = this.ctx;
      ctx.beginPath();
      this._setStyle(gst, ctx);
      this._draw(gst.pth, ctx);
      ctx.stroke();
    };
    exports.ToContext2D.prototype.PutText = function(gst, str, stw) {
      if (this.currPage != this.needPage)
        return;
      var scl = this._scale(gst.ctm);
      var ctx = this.ctx;
      this._setStyle(gst, ctx);
      ctx.save();
      var m = [1, 0, 0, -1, 0, 0];
      this._concat(m, gst.font.Tm);
      this._concat(m, gst.ctm);
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      ctx.fillText(str, 0, 0);
      ctx.restore();
    };
    exports.ToContext2D.prototype.PutImage = function(gst, buff, w, h, msk) {
      if (this.currPage != this.needPage)
        return;
      var ctx = this.ctx;
      if (buff.length == w * h * 4) {
        buff = buff.slice(0);
        if (msk && msk.length == w * h * 4)
          for (var i = 0; i < buff.length; i += 4)
            buff[i + 3] = msk[i + 1];
        var cnv = document.createElement("canvas"), cctx = cnv.getContext("2d");
        cnv.width = w;
        cnv.height = h;
        var imgd = cctx.createImageData(w, h);
        for (var i = 0; i < buff.length; i++)
          imgd.data[i] = buff[i];
        cctx.putImageData(imgd, 0, 0);
        ctx.save();
        var m = [1, 0, 0, 1, 0, 0];
        this._concat(m, [1 / w, 0, 0, -1 / h, 0, 1]);
        this._concat(m, gst.ctm);
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        ctx.drawImage(cnv, 0, 0);
        ctx.restore();
      }
    };
    exports.ToContext2D.prototype.ShowPage = function() {
      this.currPage++;
    };
    exports.ToContext2D.prototype.Done = function() {
    };
    function _flt(n) {
      return "" + parseFloat(n.toFixed(2));
    }
    exports.ToContext2D.prototype._setStyle = function(gst, ctx) {
      var scl = this._scale(gst.ctm);
      ctx.fillStyle = this._getFill(gst.colr, gst.ca, ctx);
      ctx.strokeStyle = this._getFill(gst.COLR, gst.CA, ctx);
      ctx.lineCap = ["butt", "round", "square"][gst.lcap];
      ctx.lineJoin = ["miter", "round", "bevel"][gst.ljoin];
      ctx.lineWidth = gst.lwidth * scl;
      var dsh = gst.dash.slice(0);
      for (var i = 0; i < dsh.length; i++)
        dsh[i] = _flt(dsh[i] * scl);
      ctx.setLineDash(dsh);
      ctx.miterLimit = gst.mlimit * scl;
      var fn = gst.font.Tf, ln = fn.toLowerCase();
      var p0 = ln.indexOf("bold") != -1 ? "bold " : "";
      var p1 = ln.indexOf("italic") != -1 || ln.indexOf("oblique") != -1 ? "italic " : "";
      ctx.font = p0 + p1 + gst.font.Tfs + 'px "' + fn + '"';
    };
    exports.ToContext2D.prototype._getFill = function(colr, ca, ctx) {
      if (colr.typ == null)
        return this._colr(colr, ca);
      else {
        var grd = colr, crd = grd.crds, mat = grd.mat, scl = this._scale(mat), gf;
        if (grd.typ == "lin") {
          var p0 = this._multPoint(mat, crd.slice(0, 2)), p1 = this._multPoint(mat, crd.slice(2));
          gf = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
        } else if (grd.typ == "rad") {
          var p0 = this._multPoint(mat, crd.slice(0, 2)), p1 = this._multPoint(mat, crd.slice(3));
          gf = ctx.createRadialGradient(p0[0], p0[1], crd[2] * scl, p1[0], p1[1], crd[5] * scl);
        }
        for (var i = 0; i < grd.grad.length; i++)
          gf.addColorStop(grd.grad[i][0], this._colr(grd.grad[i][1], ca));
        return gf;
      }
    };
    exports.ToContext2D.prototype._colr = function(c, a) {
      return "rgba(" + Math.round(c[0] * 255) + "," + Math.round(c[1] * 255) + "," + Math.round(c[2] * 255) + "," + a + ")";
    };
    exports.ToContext2D.prototype._scale = function(m) {
      return Math.sqrt(Math.abs(m[0] * m[3] - m[1] * m[2]));
    };
    exports.ToContext2D.prototype._concat = function(m, w) {
      var a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
      m[0] = a * w[0] + b * w[2];
      m[1] = a * w[1] + b * w[3];
      m[2] = c * w[0] + d * w[2];
      m[3] = c * w[1] + d * w[3];
      m[4] = tx * w[0] + ty * w[2] + w[4];
      m[5] = tx * w[1] + ty * w[3] + w[5];
    };
    exports.ToContext2D.prototype._multPoint = function(m, p) {
      var x = p[0], y = p[1];
      return [x * m[0] + y * m[2] + m[4], x * m[1] + y * m[3] + m[5]];
    }, exports.ToContext2D.prototype._draw = function(path, ctx) {
      var c = 0, crds = path.crds;
      for (var j = 0; j < path.cmds.length; j++) {
        var cmd = path.cmds[j];
        if (cmd == "M") {
          ctx.moveTo(crds[c], crds[c + 1]);
          c += 2;
        } else if (cmd == "L") {
          ctx.lineTo(crds[c], crds[c + 1]);
          c += 2;
        } else if (cmd == "C") {
          ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
          c += 6;
        } else if (cmd == "Q") {
          ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
          c += 4;
        } else if (cmd == "Z") {
          ctx.closePath();
        }
      }
    };
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneImage.js
var require_FortuneImage = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneImage.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageList = void 0;
    var FortuneBase_1 = require_FortuneBase();
    var emf_1 = require_emf();
    var ImageList = (
      /** @class */
      function() {
        function ImageList2(files) {
          if (files == null) {
            return;
          }
          this.images = {};
          for (var fileKey in files) {
            if (fileKey.indexOf("xl/media/") > -1) {
              var fileNameArr = fileKey.split(".");
              var suffix = fileNameArr[fileNameArr.length - 1].toLowerCase();
              if (suffix in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1, emf: 1 }) {
                if (suffix == "emf") {
                  var pNum = 0;
                  var scale = 1;
                  var wrt = new emf_1.ToContext2D(pNum, scale);
                  var inp, out, stt;
                  emf_1.FromEMF.K = [];
                  inp = emf_1.FromEMF.C;
                  out = emf_1.FromEMF.K;
                  stt = 4;
                  for (var p in inp)
                    out[inp[p]] = p.slice(stt);
                  emf_1.FromEMF.Parse(files[fileKey], wrt);
                  this.images[fileKey] = wrt.canvas.toDataURL("image/png");
                } else {
                  this.images[fileKey] = files[fileKey];
                }
              }
            }
          }
        }
        ImageList2.prototype.getImageByName = function(pathName) {
          if (pathName in this.images) {
            var base64 = this.images[pathName];
            return new Image(pathName, base64);
          }
          return null;
        };
        return ImageList2;
      }()
    );
    exports.ImageList = ImageList;
    var Image = (
      /** @class */
      function(_super) {
        __extends(Image2, _super);
        function Image2(pathName, base64) {
          var _this = _super.call(this) || this;
          _this.src = base64;
          return _this;
        }
        Image2.prototype.setDefault = function() {
        };
        return Image2;
      }(FortuneBase_1.FortuneImageBase)
    );
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneFile.js
var require_FortuneFile = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/FortuneFile.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FortuneFile = void 0;
    var FortuneSheet_1 = require_FortuneSheet();
    var constant_1 = require_constant();
    var ReadXml_1 = require_ReadXml();
    var method_1 = require_method();
    var FortuneBase_1 = require_FortuneBase();
    var FortuneImage_1 = require_FortuneImage();
    var FortuneFile = (
      /** @class */
      function() {
        function FortuneFile2(files, fileName) {
          this.columnWidthSet = [];
          this.rowHeightSet = [];
          this.files = files;
          this.fileName = fileName;
          this.readXml = new ReadXml_1.ReadXml(files);
          this.getSheetNameList();
          this.sharedStrings = this.readXml.getElementsByTagName("sst/si", constant_1.sharedStringsFile);
          this.calcChain = this.readXml.getElementsByTagName("calcChain/c", constant_1.calcChainFile);
          this.styles = {};
          this.styles["cellXfs"] = this.readXml.getElementsByTagName("cellXfs/xf", constant_1.stylesFile);
          this.styles["cellStyleXfs"] = this.readXml.getElementsByTagName("cellStyleXfs/xf", constant_1.stylesFile);
          this.styles["cellStyles"] = this.readXml.getElementsByTagName("cellStyles/cellStyle", constant_1.stylesFile);
          this.styles["fonts"] = this.readXml.getElementsByTagName("fonts/font", constant_1.stylesFile);
          this.styles["fills"] = this.readXml.getElementsByTagName("fills/fill", constant_1.stylesFile);
          this.styles["borders"] = this.readXml.getElementsByTagName("borders/border", constant_1.stylesFile);
          this.styles["clrScheme"] = this.readXml.getElementsByTagName("a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink", constant_1.theme1File);
          this.styles["indexedColors"] = this.readXml.getElementsByTagName("colors/indexedColors/rgbColor", constant_1.stylesFile);
          this.styles["mruColors"] = this.readXml.getElementsByTagName("colors/mruColors/color", constant_1.stylesFile);
          this.imageList = new FortuneImage_1.ImageList(files);
          var numfmts = this.readXml.getElementsByTagName("numFmt/numFmt", constant_1.stylesFile);
          var numFmtDefaultC = JSON.parse(JSON.stringify(constant_1.numFmtDefault));
          for (var i = 0; i < numfmts.length; i++) {
            var attrList = numfmts[i].attributeList;
            var numfmtid = (0, method_1.getXmlAttibute)(attrList, "numFmtId", "49");
            var formatcode = (0, method_1.getXmlAttibute)(attrList, "formatCode", "@");
            if (!(numfmtid in constant_1.numFmtDefault)) {
              numFmtDefaultC[numfmtid] = constant_1.numFmtDefaultMap[formatcode] || formatcode;
            }
          }
          this.styles["numfmts"] = numFmtDefaultC;
        }
        FortuneFile2.prototype.getSheetNameList = function() {
          var workbookRelList = this.readXml.getElementsByTagName("Relationships/Relationship", constant_1.workbookRels);
          if (workbookRelList == null) {
            return;
          }
          var regex = new RegExp("worksheets/[^/]*?.xml");
          var sheetNames = {};
          for (var i = 0; i < workbookRelList.length; i++) {
            var rel = workbookRelList[i], attrList = rel.attributeList;
            var id = attrList["Id"], target = attrList["Target"];
            if (regex.test(target)) {
              if (target.indexOf("/xl") === 0) {
                sheetNames[id] = target.substr(1);
              } else {
                sheetNames[id] = "xl/" + target;
              }
            }
          }
          this.sheetNameList = sheetNames;
        };
        FortuneFile2.prototype.getSheetFileBysheetId = function(sheetId) {
          return this.sheetNameList[sheetId];
        };
        FortuneFile2.prototype.getWorkBookInfo = function() {
          var Company = this.readXml.getElementsByTagName("Company", constant_1.appFile);
          var AppVersion = this.readXml.getElementsByTagName("AppVersion", constant_1.appFile);
          var creator = this.readXml.getElementsByTagName("dc:creator", constant_1.coreFile);
          var lastModifiedBy = this.readXml.getElementsByTagName("cp:lastModifiedBy", constant_1.coreFile);
          var created = this.readXml.getElementsByTagName("dcterms:created", constant_1.coreFile);
          var modified = this.readXml.getElementsByTagName("dcterms:modified", constant_1.coreFile);
          this.info = new FortuneBase_1.FortuneFileInfo();
          this.info.name = this.fileName;
          this.info.creator = creator.length > 0 ? creator[0].value : "";
          this.info.lastmodifiedby = lastModifiedBy.length > 0 ? lastModifiedBy[0].value : "";
          this.info.createdTime = created.length > 0 ? created[0].value : "";
          this.info.modifiedTime = modified.length > 0 ? modified[0].value : "";
          this.info.company = Company.length > 0 ? Company[0].value : "";
          this.info.appversion = AppVersion.length > 0 ? AppVersion[0].value : "";
        };
        FortuneFile2.prototype.getSheetsFull = function(isInitialCell) {
          if (isInitialCell === void 0) {
            isInitialCell = true;
          }
          var sheets = this.readXml.getElementsByTagName("sheets/sheet", constant_1.workBookFile);
          var sheetList = {};
          for (var key in sheets) {
            var sheet = sheets[key];
            sheetList[sheet.attributeList.name] = sheet.attributeList["sheetId"];
          }
          this.sheets = [];
          var order = 0;
          for (var key in sheets) {
            var sheet = sheets[key];
            var sheetName = sheet.attributeList.name;
            var sheetId = sheet.attributeList["sheetId"];
            var rid = sheet.attributeList["r:id"];
            var sheetFile = this.getSheetFileBysheetId(rid);
            var hide = sheet.attributeList.state === "hidden" ? 1 : 0;
            var drawing = this.readXml.getElementsByTagName("worksheet/drawing", sheetFile), drawingFile = void 0, drawingRelsFile = void 0;
            if (drawing != null && drawing.length > 0) {
              var attrList = drawing[0].attributeList;
              var rid_1 = (0, method_1.getXmlAttibute)(attrList, "r:id", null);
              if (rid_1 != null) {
                drawingFile = this.getDrawingFile(rid_1, sheetFile);
                drawingRelsFile = this.getDrawingRelsFile(drawingFile);
              }
            }
            if (sheetFile != null) {
              var sheet_1 = new FortuneSheet_1.FortuneSheet(sheetName, sheetId, order, isInitialCell, {
                sheetFile,
                readXml: this.readXml,
                sheetList,
                styles: this.styles,
                sharedStrings: this.sharedStrings,
                calcChain: this.calcChain,
                imageList: this.imageList,
                drawingFile,
                drawingRelsFile,
                hide
              });
              this.columnWidthSet = [];
              this.rowHeightSet = [];
              this.imagePositionCaculation(sheet_1);
              this.sheets.push(sheet_1);
              order++;
            }
          }
        };
        FortuneFile2.prototype.extendArray = function(index, sets, def, hidden, lens) {
          if (index < sets.length) {
            return;
          }
          var startIndex = sets.length, endIndex = index;
          var allGap = 0;
          if (startIndex > 0) {
            allGap = sets[startIndex - 1];
          }
          for (var i = startIndex; i <= endIndex; i++) {
            var gap = def, istring = i.toString();
            if (istring in hidden) {
              gap = 0;
            } else if (istring in lens) {
              gap = lens[istring];
            }
            allGap += Math.round(gap + 1);
            sets.push(allGap);
          }
        };
        FortuneFile2.prototype.imagePositionCaculation = function(sheet) {
          var images = sheet.images, defaultColWidth = sheet.defaultColWidth, defaultRowHeight = sheet.defaultRowHeight;
          var colhidden = {};
          if (sheet.config.colhidden) {
            colhidden = sheet.config.colhidden;
          }
          var columnlen = {};
          if (sheet.config.columnlen) {
            columnlen = sheet.config.columnlen;
          }
          var rowhidden = {};
          if (sheet.config.rowhidden) {
            rowhidden = sheet.config.rowhidden;
          }
          var rowlen = {};
          if (sheet.config.rowlen) {
            rowlen = sheet.config.rowlen;
          }
          for (var key in images) {
            var imageObject = images[key];
            var fromCol = imageObject.fromCol;
            var fromColOff = imageObject.fromColOff;
            var fromRow = imageObject.fromRow;
            var fromRowOff = imageObject.fromRowOff;
            var toCol = imageObject.toCol;
            var toColOff = imageObject.toColOff;
            var toRow = imageObject.toRow;
            var toRowOff = imageObject.toRowOff;
            var x_n = 0, y_n = 0;
            var cx_n = 0, cy_n = 0;
            if (fromCol >= this.columnWidthSet.length) {
              this.extendArray(fromCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);
            }
            if (fromCol == 0) {
              x_n = 0;
            } else {
              x_n = this.columnWidthSet[fromCol - 1];
            }
            x_n = x_n + fromColOff;
            if (fromRow >= this.rowHeightSet.length) {
              this.extendArray(fromRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);
            }
            if (fromRow == 0) {
              y_n = 0;
            } else {
              y_n = this.rowHeightSet[fromRow - 1];
            }
            y_n = y_n + fromRowOff;
            if (toCol >= this.columnWidthSet.length) {
              this.extendArray(toCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);
            }
            if (toCol == 0) {
              cx_n = 0;
            } else {
              cx_n = this.columnWidthSet[toCol - 1];
            }
            cx_n = cx_n + toColOff - x_n;
            if (toRow >= this.rowHeightSet.length) {
              this.extendArray(toRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);
            }
            if (toRow == 0) {
              cy_n = 0;
            } else {
              cy_n = this.rowHeightSet[toRow - 1];
            }
            cy_n = cy_n + toRowOff - y_n;
            console.log(defaultColWidth, colhidden, columnlen);
            console.log(fromCol, this.columnWidthSet[fromCol], fromColOff);
            console.log(toCol, this.columnWidthSet[toCol], toColOff, JSON.stringify(this.columnWidthSet));
            imageObject.originWidth = cx_n;
            imageObject.originHeight = cy_n;
            imageObject.crop.height = cy_n;
            imageObject.crop.width = cx_n;
            imageObject.default.height = cy_n;
            imageObject.default.left = x_n;
            imageObject.default.top = y_n;
            imageObject.default.width = cx_n;
          }
        };
        FortuneFile2.prototype.getDrawingFile = function(rid, sheetFile) {
          var sheetRelsPath = "xl/worksheets/_rels/";
          var sheetFileArr = sheetFile.split("/");
          var sheetRelsName = sheetFileArr[sheetFileArr.length - 1];
          var sheetRelsFile = sheetRelsPath + sheetRelsName + ".rels";
          var drawing = this.readXml.getElementsByTagName("Relationships/Relationship", sheetRelsFile);
          if (drawing.length > 0) {
            for (var i = 0; i < drawing.length; i++) {
              var relationship = drawing[i];
              var attrList = relationship.attributeList;
              var relationshipId = (0, method_1.getXmlAttibute)(attrList, "Id", null);
              if (relationshipId == rid) {
                var target = (0, method_1.getXmlAttibute)(attrList, "Target", null);
                if (target != null) {
                  return target.replace(/\.\.\//g, "");
                }
              }
            }
          }
          return null;
        };
        FortuneFile2.prototype.getDrawingRelsFile = function(drawingFile) {
          var drawingRelsPath = "xl/drawings/_rels/";
          var drawingFileArr = drawingFile.split("/");
          var drawingRelsName = drawingFileArr[drawingFileArr.length - 1];
          var drawingRelsFile = drawingRelsPath + drawingRelsName + ".rels";
          return drawingRelsFile;
        };
        FortuneFile2.prototype.getSheetsWithoutCell = function() {
          this.getSheetsFull(false);
        };
        FortuneFile2.prototype.Parse = function() {
          this.getWorkBookInfo();
          this.getSheetsFull();
        };
        FortuneFile2.prototype.serialize = function() {
          var _a;
          var FortuneOutPutFile = new FortuneBase_1.FortuneFileBase();
          FortuneOutPutFile.info = this.info;
          FortuneOutPutFile.sheets = [];
          for (var _i = 0, _b = this.sheets; _i < _b.length; _i++) {
            var sheet = _b[_i];
            var sheetout = {};
            if (sheet.name != null) {
              sheetout.name = sheet.name;
            }
            if (sheet.color != null) {
              sheetout.color = sheet.color;
            }
            if (sheet.config != null) {
              sheetout.config = sheet.config;
            }
            if (sheet.id != null) {
              sheetout.id = sheet.id;
            }
            if (sheet.status != null) {
              sheetout.status = sheet.status;
            }
            if (sheet.order != null) {
              sheetout.order = sheet.order;
            }
            if (sheet.row != null) {
              sheetout.row = sheet.row;
            }
            if (sheet.column != null) {
              sheetout.column = sheet.column;
            }
            if (sheet.luckysheet_select_save != null) {
              sheetout.luckysheet_select_save = sheet.luckysheet_select_save;
            }
            if (sheet.scrollLeft != null) {
              sheetout.scrollLeft = sheet.scrollLeft;
            }
            if (sheet.scrollTop != null) {
              sheetout.scrollTop = sheet.scrollTop;
            }
            if (sheet.zoomRatio != null) {
              sheetout.zoomRatio = sheet.zoomRatio;
            }
            if (sheet.showGridLines != null) {
              sheetout.showGridLines = sheet.showGridLines;
            }
            if (sheet.defaultColWidth != null) {
              sheetout.defaultColWidth = sheet.defaultColWidth;
            }
            if (sheet.defaultRowHeight != null) {
              sheetout.defaultRowHeight = sheet.defaultRowHeight;
            }
            var merges = /* @__PURE__ */ new Map();
            if ((_a = sheet.config) === null || _a === void 0 ? void 0 : _a.merge) {
              for (var _c = 0, _d = Object.values(sheet.config.merge); _c < _d.length; _c++) {
                var _e = _d[_c], r = _e.r, c = _e.c, rs = _e.rs, cs = _e.cs;
                merges.set(r + "_" + c, { r, c, rs, cs });
                for (var i = r + 1; i < r + rs; i++)
                  for (var j = c + 1; j < c + cs; j++)
                    merges.set(i + "_" + j, { r, c });
              }
            }
            if (sheet.celldata != null) {
              sheetout.celldata = [];
              for (var _f = 0, _g = sheet.celldata; _f < _g.length; _f++) {
                var _h = _g[_f], r = _h.r, c = _h.c, v = _h.v;
                if (typeof v === "object") {
                  var xv = __rest(v, []);
                  v = xv;
                  if (v.ct) {
                    var ct = __rest(v.ct, []);
                    v.ct = ct;
                  }
                  if (merges.has(r + "_" + c)) {
                    v.mc = merges.get(r + "_" + c);
                    if (v.mc.r !== r || v.mc.c !== c)
                      v = { mc: v.mc };
                  }
                }
                sheetout.celldata.push({ r, c, v });
              }
            }
            if (sheet.chart != null) {
              sheetout.chart = sheet.chart;
            }
            if (sheet.isPivotTable != null) {
              sheetout.isPivotTable = sheet.isPivotTable;
            }
            if (sheet.pivotTable != null) {
              sheetout.pivotTable = sheet.pivotTable;
            }
            if (sheet.luckysheet_conditionformat_save != null) {
              sheetout.luckysheet_conditionformat_save = sheet.luckysheet_conditionformat_save;
            }
            if (sheet.freezen != null) {
              sheetout.freezen = sheet.freezen;
            }
            if (sheet.calcChain != null) {
              sheetout.calcChain = sheet.calcChain;
            }
            if (sheet.images != null) {
              sheetout.images = sheet.images;
            }
            if (sheet.dataVerification != null) {
              sheetout.dataVerification = sheet.dataVerification;
            }
            if (sheet.hyperlink != null) {
              sheetout.hyperlink = sheet.hyperlink;
            }
            if (sheet.hide != null) {
              sheetout.hide = sheet.hide;
            }
            FortuneOutPutFile.sheets.push(sheetout);
          }
          return FortuneOutPutFile;
        };
        return FortuneFile2;
      }()
    );
    exports.FortuneFile = FortuneFile;
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof __require && __require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/HandleZip.js
var require_HandleZip = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/HandleZip.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandleZip = void 0;
    var jszip_1 = __importDefault(require_jszip_min());
    var HandleZip = (
      /** @class */
      function() {
        function HandleZip2(file) {
          this.uploadFile = file;
        }
        HandleZip2.prototype.unzipFile = function() {
          return __awaiter(this, void 0, void 0, function() {
            var zip, fileList, _i, _a, _b, _path, zipEntry, fileName, fileNameArr, suffix, fileType, data;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, jszip_1.default.loadAsync(this.uploadFile)];
                case 1:
                  zip = _c.sent();
                  fileList = {};
                  _i = 0, _a = Object.entries(zip.files);
                  _c.label = 2;
                case 2:
                  if (!(_i < _a.length))
                    return [3, 5];
                  _b = _a[_i], _path = _b[0], zipEntry = _b[1];
                  fileName = zipEntry.name;
                  fileNameArr = fileName.split(".");
                  suffix = fileNameArr[fileNameArr.length - 1].toLowerCase();
                  fileType = "string";
                  if (suffix in {
                    png: 1,
                    jpeg: 1,
                    jpg: 1,
                    gif: 1,
                    bmp: 1,
                    tif: 1,
                    webp: 1
                  }) {
                    fileType = "base64";
                  } else if (suffix == "emf") {
                    fileType = "arraybuffer";
                  }
                  return [4, zipEntry.async(fileType)];
                case 3:
                  data = _c.sent();
                  if (fileType == "base64") {
                    data = "data:image/" + suffix + ";base64," + data;
                  }
                  fileList[zipEntry.name] = data;
                  _c.label = 4;
                case 4:
                  _i++;
                  return [3, 2];
                case 5:
                  return [2, fileList];
              }
            });
          });
        };
        return HandleZip2;
      }()
    );
    exports.HandleZip = HandleZip;
  }
});

// node_modules/file-saver/dist/FileSaver.min.js
var require_FileSaver_min = __commonJS({
  "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
    (function(a, b) {
      if ("function" == typeof define && define.amd)
        define([], b);
      else if ("undefined" != typeof exports)
        b();
      else {
        b(), a.FileSaver = { exports: {} }.exports;
      }
    })(exports, function() {
      "use strict";
      function b(a2, b2) {
        return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
      }
      function c(a2, b2, c2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
          g(d2.response, b2, c2);
        }, d2.onerror = function() {
          console.error("could not download file");
        }, d2.send();
      }
      function d(a2) {
        var b2 = new XMLHttpRequest();
        b2.open("HEAD", a2, false);
        try {
          b2.send();
        } catch (a3) {
        }
        return 200 <= b2.status && 299 >= b2.status;
      }
      function e(a2) {
        try {
          a2.dispatchEvent(new MouseEvent("click"));
        } catch (c2) {
          var b2 = document.createEvent("MouseEvents");
          b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
        }
      }
      var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
          i.revokeObjectURL(j.href);
        }, 4e4), setTimeout(function() {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
        if (g2 = g2 || f2.name || "download", "string" != typeof f2)
          navigator.msSaveOrOpenBlob(b(f2, h), g2);
        else if (d(f2))
          c(f2, g2, h);
        else {
          var i = document.createElement("a");
          i.href = f2, i.target = "_blank", setTimeout(function() {
            e(i);
          });
        }
      } : function(b2, d2, e2, g2) {
        if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
          return c(b2, d2, e2);
        var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
          var k = new FileReader();
          k.onloadend = function() {
            var a2 = k.result;
            a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
          }, k.readAsDataURL(b2);
        } else {
          var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
          g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
            l.revokeObjectURL(m);
          }, 4e4);
        }
      });
      f.saveAs = g.saveAs = g, "undefined" != typeof module && (module.exports = g);
    });
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelConvert.js
var require_ExcelConvert = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelConvert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.alignmentConvert = exports.fontConvert = exports.fillConvert = void 0;
    var constant_1 = require_constant();
    var method_1 = require_method();
    var fillConvert = function(bg) {
      if (!bg) {
        return null;
      }
      bg = bg.indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(bg) : bg;
      var fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: bg.replace("#", "") }
      };
      return fill;
    };
    exports.fillConvert = fillConvert;
    var fontConvert = function(ff, fc, bl, it, fs, cl, ul) {
      if (ff === void 0) {
        ff = "";
      }
      if (fc === void 0) {
        fc = "#000000";
      }
      if (bl === void 0) {
        bl = 0;
      }
      if (it === void 0) {
        it = 0;
      }
      if (fs === void 0) {
        fs = 10;
      }
      if (cl === void 0) {
        cl = 0;
      }
      if (ul === void 0) {
        ul = 0;
      }
      var luckyToExcel = {
        0: "微软雅黑",
        1: "宋体（Song）",
        2: "黑体（ST Heiti）",
        3: "楷体（ST Kaiti）",
        4: "仿宋（ST FangSong）",
        5: "新宋体（ST Song）",
        6: "华文新魏",
        7: "华文行楷",
        8: "华文隶书",
        9: "Arial",
        10: "Times New Roman ",
        11: "Tahoma ",
        12: "Verdana",
        num2bl: function(num) {
          return num === 0 ? false : true;
        }
      };
      var color = (fc + "").indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(fc) : fc;
      var font = {
        name: ff,
        family: 1,
        size: fs,
        color: { argb: color.replace("#", "") },
        bold: luckyToExcel.num2bl(bl),
        italic: luckyToExcel.num2bl(it),
        underline: luckyToExcel.num2bl(ul),
        strike: luckyToExcel.num2bl(cl)
      };
      return font;
    };
    exports.fontConvert = fontConvert;
    var alignmentConvert = function(vt, ht, tb, tr) {
      if (vt === void 0) {
        vt = constant_1.ALIGNMENT_DEFAULT;
      }
      if (ht === void 0) {
        ht = constant_1.ALIGNMENT_DEFAULT;
      }
      if (tb === void 0) {
        tb = constant_1.ALIGNMENT_DEFAULT;
      }
      if (tr === void 0) {
        tr = constant_1.ALIGNMENT_DEFAULT;
      }
      var luckyToExcel = {
        vertical: {
          0: "middle",
          1: "top",
          2: "bottom",
          ALIGNMENT_DEFAULT: "top"
        },
        horizontal: {
          0: "center",
          1: "left",
          2: "right",
          ALIGNMENT_DEFAULT: "left"
        },
        wrapText: {
          0: false,
          1: false,
          2: true,
          ALIGNMENT_DEFAULT: false
        },
        textRotation: {
          0: 0,
          1: 45,
          2: -45,
          3: "vertical",
          4: 90,
          5: -90,
          ALIGNMENT_DEFAULT: 0
        }
      };
      var alignment = {
        vertical: luckyToExcel.vertical[vt],
        horizontal: luckyToExcel.horizontal[ht],
        wrapText: luckyToExcel.wrapText[tb],
        textRotation: luckyToExcel.textRotation[tr]
      };
      return alignment;
    };
    exports.alignmentConvert = alignmentConvert;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelStyle.js
var require_ExcelStyle = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelStyle.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setStyleAndValue = void 0;
    var lodash_1 = __importDefault(require_lodash());
    var ExcelConvert_1 = require_ExcelConvert();
    var isTime = function(d) {
      return d === "hh:mm";
    };
    var formatHyperlink = function(address) {
      var sheetCell = address.split("!");
      return "#'".concat(sheetCell[0], "'!").concat(sheetCell[1] || "A1");
    };
    var setStyleAndValue = function(luckysheet, table, worksheet) {
      var cellArr = table === null || table === void 0 ? void 0 : table.data;
      if (!Array.isArray(cellArr))
        return;
      cellArr.forEach(function(row, rowid) {
        var dbrow = worksheet.getRow(rowid + 1);
        dbrow.height = luckysheet.getRowHeight([rowid])[rowid] / 1.2;
        row.every(function(cell, columnid) {
          var _a;
          if (!cell || lodash_1.default.isNil(cell.v) || lodash_1.default.isNaN(cell.v))
            return true;
          if (rowid == 0) {
            var dobCol = worksheet.getColumn(columnid + 1);
            dobCol.width = luckysheet.getColumnWidth([columnid])[columnid] / 8;
          }
          var fill = (0, ExcelConvert_1.fillConvert)(cell.bg);
          var font = (0, ExcelConvert_1.fontConvert)(cell.ff, cell.fc, cell.bl, cell.it, cell.fs, cell.cl, cell.un);
          var alignment = (0, ExcelConvert_1.alignmentConvert)(cell.vt, cell.ht, cell.tb && parseInt(cell.tb, 10), cell.tr && parseInt(cell.tr, 10));
          var value;
          var v = "";
          var numFmt = void 0;
          if (cell.hl) {
            var hlData = (_a = table.hyperlink) === null || _a === void 0 ? void 0 : _a["".concat(cell.hl.r, "_").concat(cell.hl.c)];
            if ((hlData === null || hlData === void 0 ? void 0 : hlData.linkType) === "webpage") {
              v = {
                text: cell.v,
                hyperlink: hlData === null || hlData === void 0 ? void 0 : hlData.linkAddress,
                tooltip: cell.v
              };
            } else if (hlData.linkType === "cellrange" || hlData.linkType === "sheet") {
              v = { text: cell.v, hyperlink: formatHyperlink(hlData === null || hlData === void 0 ? void 0 : hlData.linkAddress) };
            }
          } else if (cell.ct && cell.ct.t == "inlineStr") {
            var s = cell.ct.s;
            s.forEach(function(val, num) {
              v += val.v;
            });
          } else if (cell.ct && cell.ct.t == "n") {
            v = +cell.v;
            if (cell.ct !== "General")
              numFmt = cell.ct.fa;
          } else if (cell.ct && cell.ct.t == "d") {
            var mockDate = isTime(cell.ct.fa) ? "2000-01-01 " : "";
            v = new Date(mockDate + cell.m);
            numFmt = cell.ct.fa;
          } else {
            v = cell.v;
          }
          if (cell.f && typeof v !== "object") {
            value = {
              formula: cell.f.startsWith("=") ? cell.f.slice(1) : cell.f,
              result: v
            };
          } else {
            value = v;
          }
          var target = worksheet.getCell(rowid + 1, columnid + 1);
          target.fill = fill;
          target.font = font;
          target.alignment = alignment;
          target.value = value;
          target.numFmt = numFmt;
          return true;
        });
      });
    };
    exports.setStyleAndValue = setStyleAndValue;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelImage.js
var require_ExcelImage = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelImage.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setImages = void 0;
    var getImagePosition = function(num, arr) {
      var index = 0;
      var minIndex;
      var maxIndex;
      for (var i = 0; i < arr.length; i++) {
        if (num < arr[i]) {
          index = i;
          break;
        }
      }
      if (index == 0) {
        minIndex = 0;
        maxIndex = 1;
        return Math.abs((num - 0) / (arr[maxIndex] - arr[minIndex])) + index;
      } else if (index == arr.length - 1) {
        minIndex = arr.length - 2;
        maxIndex = arr.length - 1;
      } else {
        minIndex = index - 1;
        maxIndex = index;
      }
      var min = arr[minIndex];
      var max = arr[maxIndex];
      var radio = Math.abs((num - min) / (max - min)) + index;
      return radio;
    };
    var setImages = function(table, worksheet, workbook) {
      var _a, _b, _c, _d;
      var localTable = __assign({}, table);
      var images = localTable.images, visibledatacolumn = localTable.visibledatacolumn, visibledatarow = localTable.visibledatarow;
      if (typeof images != "object")
        return;
      for (var key in images) {
        var myBase64Image = images[key].src;
        var item = images[key];
        var imageId = workbook.addImage({
          base64: myBase64Image,
          extension: "png"
        });
        if (!visibledatacolumn || !visibledatarow) {
          var defaultColWidth = localTable.defaultColWidth || 73;
          var defaultRowHeight = localTable.defaultRowHeight || 19;
          var rowCount = localTable.data.length;
          var colCount = localTable.data[0].length;
          visibledatacolumn = [];
          visibledatarow = [];
          var lastVal = 0;
          for (var i = 0; i < rowCount; i++) {
            var rowHeight = ((_b = (_a = localTable.config) === null || _a === void 0 ? void 0 : _a.rowlen) === null || _b === void 0 ? void 0 : _b[i]) || defaultRowHeight;
            var rowPosition = lastVal + rowHeight;
            visibledatarow.push(rowPosition);
            lastVal = rowPosition;
          }
          lastVal = 0;
          for (var i = 0; i < colCount; i++) {
            var colWidth = ((_d = (_c = localTable.config) === null || _c === void 0 ? void 0 : _c.columnlen) === null || _d === void 0 ? void 0 : _d[i]) || defaultColWidth;
            var colPosition = lastVal + colWidth;
            visibledatacolumn.push(colPosition);
            lastVal = colPosition;
          }
        }
        var col_st = getImagePosition(item.left, visibledatacolumn);
        var row_st = getImagePosition(item.top, visibledatarow);
        worksheet.addImage(imageId, {
          tl: { col: col_st, row: row_st },
          ext: { width: item.width, height: item.height }
        });
      }
    };
    exports.setImages = setImages;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelBorder.js
var require_ExcelBorder = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelBorder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBorder = void 0;
    var method_1 = require_method();
    var setBorder = function(lucksheetfile, worksheet) {
      if (!lucksheetfile)
        return;
      var luckyToExcel = {
        style: {
          0: "none",
          1: "thin",
          2: "hair",
          3: "dotted",
          4: "dashDot",
          // 'Dashed',
          5: "dashDot",
          6: "dashDotDot",
          7: "double",
          8: "medium",
          9: "mediumDashed",
          10: "mediumDashDot",
          11: "mediumDashDotDot",
          12: "slantDashDot",
          13: "thick"
        }
      };
      var borderInfoCompute = getBorderInfo(lucksheetfile);
      for (var x in borderInfoCompute) {
        var border = {};
        var info = borderInfoCompute[x];
        var row = parseInt(x.substr(0, x.indexOf("_")));
        var column = parseInt(x.substr(x.indexOf("_") + 1));
        if (info.t != void 0) {
          var tcolor = info.t.color.indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(info.t.color) : info.t.color;
          border["top"] = {
            style: luckyToExcel.style[info.t.style],
            color: { argb: tcolor.replace("#", "") }
          };
        }
        if (info.r != void 0) {
          var rcolor = info.r.color.indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(info.r.color) : info.r.color;
          border["right"] = {
            style: luckyToExcel.style[info.r.style],
            color: { argb: rcolor.replace("#", "") }
          };
        }
        if (info.b != void 0) {
          var bcolor = info.b.color.indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(info.b.color) : info.b.color;
          border["bottom"] = {
            style: luckyToExcel.style[info.b.style],
            color: { argb: bcolor.replace("#", "") }
          };
        }
        if (info.l != void 0) {
          var lcolor = info.l.color.indexOf("rgb") > -1 ? (0, method_1.rgb2hex)(info.l.color) : info.l.color;
          border["left"] = {
            style: luckyToExcel.style[info.l.style],
            color: { argb: lcolor.replace("#", "") }
          };
        }
        worksheet.getCell(row + 1, column + 1).border = border;
      }
    };
    exports.setBorder = setBorder;
    var getBorderInfo = function(luckysheetfile) {
      var _a, _b, _c, _d;
      var borderInfoCompute = {};
      var cfg = luckysheetfile.config;
      var data = luckysheetfile.data;
      if (!cfg || !data)
        return {};
      var borderInfo = cfg["borderInfo"];
      var dataset_row_st = 0, dataset_row_ed = data.length, dataset_col_st = 0, dataset_col_ed = data[0].length;
      if (borderInfo != null && borderInfo.length > 0) {
        for (var i = 0; i < borderInfo.length; i++) {
          var rangeType = borderInfo[i].rangeType;
          if (rangeType == "range") {
            var borderType = borderInfo[i].borderType;
            var borderColor = borderInfo[i].color;
            var borderStyle = borderInfo[i].style;
            var borderRange = borderInfo[i].range;
            for (var j = 0; j < borderRange.length; j++) {
              var bd_r1 = borderRange[j].row[0], bd_r2 = borderRange[j].row[1];
              var bd_c1 = borderRange[j].column[0], bd_c2 = borderRange[j].column[1];
              if (bd_r1 < dataset_row_st) {
                bd_r1 = dataset_row_st;
              }
              if (bd_r2 > dataset_row_ed) {
                bd_r2 = dataset_row_ed;
              }
              if (bd_c1 < dataset_col_st) {
                bd_c1 = dataset_col_st;
              }
              if (bd_c2 > dataset_col_ed) {
                bd_c2 = dataset_col_ed;
              }
              if (borderType == "border-left") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  if (borderInfoCompute[bd_r + "_" + bd_c1] == null) {
                    borderInfoCompute[bd_r + "_" + bd_c1] = {};
                  }
                  borderInfoCompute[bd_r + "_" + bd_c1].l = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var bd_c_left = bd_c1 - 1;
                  if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_left]) == "object" && data[bd_r][bd_c_left].mc != null) {
                      var cell_left = data[bd_r][bd_c_left];
                      var mc_1 = cfg["merge"][((_a = cell_left === null || cell_left === void 0 ? void 0 : cell_left.mc) === null || _a === void 0 ? void 0 : _a.r) + "_" + ((_b = cell_left === null || cell_left === void 0 ? void 0 : cell_left.mc) === null || _b === void 0 ? void 0 : _b.c)];
                      if (mc_1.c + mc_1.cs - 1 == bd_c_left) {
                        borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                  var mc = cfg["merge"] || {};
                  for (var key in mc) {
                    var _e = mc[key], c = _e.c, r = _e.r, cs = _e.cs, rs = _e.rs;
                    if (bd_c1 <= c + cs - 1 && bd_c1 > c && bd_r >= r && bd_r <= r + rs - 1) {
                      borderInfoCompute[bd_r + "_" + bd_c1].l = null;
                    }
                  }
                }
              } else if (borderType == "border-right") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  if (borderInfoCompute[bd_r + "_" + bd_c2] == null) {
                    borderInfoCompute[bd_r + "_" + bd_c2] = {};
                  }
                  borderInfoCompute[bd_r + "_" + bd_c2].r = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var bd_c_right = bd_c2 + 1;
                  if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_right]) == "object" && data[bd_r][bd_c_right].mc != null) {
                      var cell_right = data[bd_r][bd_c_right];
                      var mc_2 = cfg["merge"][cell_right.mc.r + "_" + cell_right.mc.c];
                      if (mc_2.c == bd_c_right) {
                        borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                  var mc = cfg["merge"] || {};
                  for (var key in mc) {
                    var _f = mc[key], c = _f.c, r = _f.r, cs = _f.cs, rs = _f.rs;
                    if (bd_c2 < c + cs - 1 && bd_c2 >= c && bd_r >= r && bd_r <= r + rs - 1) {
                      borderInfoCompute[bd_r + "_" + bd_c2].r = null;
                    }
                  }
                }
              } else if (borderType == "border-top") {
                if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r1] != null) {
                  continue;
                }
                for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                  if (borderInfoCompute[bd_r1 + "_" + bd_c] == null) {
                    borderInfoCompute[bd_r1 + "_" + bd_c] = {};
                  }
                  borderInfoCompute[bd_r1 + "_" + bd_c].t = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var bd_r_top = bd_r1 - 1;
                  if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                    if (data[bd_r_top] != null && (0, method_1.getObjType)(data[bd_r_top][bd_c]) == "object" && data[bd_r_top][bd_c].mc != null) {
                      var cell_top = data[bd_r_top][bd_c];
                      var mc_3 = cfg["merge"][cell_top.mc.r + "_" + cell_top.mc.c];
                      if (mc_3.r + mc_3.rs - 1 == bd_r_top) {
                        borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                  var mc = cfg["merge"] || {};
                  for (var key in mc) {
                    var _g = mc[key], c = _g.c, r = _g.r, cs = _g.cs, rs = _g.rs;
                    if (bd_r1 <= r + rs - 1 && bd_r1 > r && bd_c >= c && bd_c <= c + cs - 1) {
                      borderInfoCompute[bd_r1 + "_" + bd_c].t = null;
                    }
                  }
                }
              } else if (borderType == "border-bottom") {
                if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r2] != null) {
                  continue;
                }
                for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                  if (borderInfoCompute[bd_r2 + "_" + bd_c] == null) {
                    borderInfoCompute[bd_r2 + "_" + bd_c] = {};
                  }
                  borderInfoCompute[bd_r2 + "_" + bd_c].b = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var bd_r_bottom = bd_r2 + 1;
                  if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                    if (data[bd_r_bottom] != null && (0, method_1.getObjType)(data[bd_r_bottom][bd_c]) == "object" && data[bd_r_bottom][bd_c].mc != null) {
                      var cell_bottom = data[bd_r_bottom][bd_c];
                      var mc_4 = cfg["merge"][cell_bottom.mc.r + "_" + cell_bottom.mc.c];
                      if (mc_4.r == bd_r_bottom) {
                        borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                  var mc = cfg["merge"] || {};
                  for (var key in mc) {
                    var _h = mc[key], c = _h.c, r = _h.r, cs = _h.cs, rs = _h.rs;
                    if (bd_r2 < r + rs - 1 && bd_r2 >= r && bd_c >= c && bd_c <= c + cs - 1) {
                      borderInfoCompute[bd_r2 + "_" + bd_c].b = null;
                    }
                  }
                }
              } else if (borderType == "border-all") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      var cell = data[bd_r][bd_c];
                      var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                      if (mc == void 0 || mc == null) {
                        continue;
                      }
                      if (mc.r == bd_r) {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                      if (mc.r + mc.rs - 1 == bd_r) {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                      if (mc.c == bd_c) {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                      if (mc.c + mc.cs - 1 == bd_c) {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                        borderInfoCompute[bd_r + "_" + bd_c] = {};
                      }
                      borderInfoCompute[bd_r + "_" + bd_c].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                      borderInfoCompute[bd_r + "_" + bd_c].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                      borderInfoCompute[bd_r + "_" + bd_c].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                      borderInfoCompute[bd_r + "_" + bd_c].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    if (bd_r == bd_r1) {
                      var bd_r_top = bd_r1 - 1;
                      if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                        if (data[bd_r_top] != null && (0, method_1.getObjType)(data[bd_r_top][bd_c]) == "object" && data[bd_r_top][bd_c].mc != null) {
                          var cell_top = data[bd_r_top][bd_c];
                          var mc = cfg["merge"][cell_top.mc.r + "_" + cell_top.mc.c];
                          if (mc.r + mc.rs - 1 == bd_r_top) {
                            borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_r == bd_r2) {
                      var bd_r_bottom = bd_r2 + 1;
                      if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                        if (data[bd_r_bottom] != null && (0, method_1.getObjType)(data[bd_r_bottom][bd_c]) == "object" && data[bd_r_bottom][bd_c].mc != null) {
                          var cell_bottom = data[bd_r_bottom][bd_c];
                          var mc = cfg["merge"][cell_bottom.mc.r + "_" + cell_bottom.mc.c];
                          if (mc.r == bd_r_bottom) {
                            borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_c == bd_c1) {
                      var bd_c_left = bd_c1 - 1;
                      if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                        if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_left]) == "object" && data[bd_r][bd_c_left].mc != null) {
                          var cell_left = data[bd_r][bd_c_left];
                          var mc = cfg["merge"][cell_left.mc.r + "_" + cell_left.mc.c];
                          if (mc.c + mc.cs - 1 == bd_c_left) {
                            borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_c == bd_c2) {
                      var bd_c_right = bd_c2 + 1;
                      if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                        if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_right]) == "object" && data[bd_r][bd_c_right].mc != null) {
                          var cell_right = data[bd_r][bd_c_right];
                          var mc = cfg["merge"][cell_right.mc.r + "_" + cell_right.mc.c];
                          if (mc.c == bd_c_right) {
                            borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                  }
                }
              } else if (borderType == "border-outside") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (!(bd_r == bd_r1 || bd_r == bd_r2 || bd_c == bd_c1 || bd_c == bd_c2)) {
                      continue;
                    }
                    if (bd_r == bd_r1) {
                      if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                        borderInfoCompute[bd_r + "_" + bd_c] = {};
                      }
                      borderInfoCompute[bd_r + "_" + bd_c].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                      var bd_r_top = bd_r1 - 1;
                      if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                        if (data[bd_r_top] != null && (0, method_1.getObjType)(data[bd_r_top][bd_c]) == "object" && data[bd_r_top][bd_c].mc != null) {
                          var cell_top = data[bd_r_top][bd_c];
                          var mc = cfg["merge"][((_c = cell_top === null || cell_top === void 0 ? void 0 : cell_top.mc) === null || _c === void 0 ? void 0 : _c.r) + "_" + ((_d = cell_top === null || cell_top === void 0 ? void 0 : cell_top.mc) === null || _d === void 0 ? void 0 : _d.c)];
                          if (mc.r + mc.rs - 1 == bd_r_top) {
                            borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_r == bd_r2) {
                      if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                        borderInfoCompute[bd_r + "_" + bd_c] = {};
                      }
                      borderInfoCompute[bd_r + "_" + bd_c].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                      var bd_r_bottom = bd_r2 + 1;
                      if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                        if (data[bd_r_bottom] != null && (0, method_1.getObjType)(data[bd_r_bottom][bd_c]) == "object" && data[bd_r_bottom][bd_c].mc != null) {
                          var cell_bottom = data[bd_r_bottom][bd_c];
                          var mc = cfg["merge"][cell_bottom.mc.r + "_" + cell_bottom.mc.c];
                          if (mc.r == bd_r_bottom) {
                            borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_c == bd_c1) {
                      if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                        borderInfoCompute[bd_r + "_" + bd_c] = {};
                      }
                      borderInfoCompute[bd_r + "_" + bd_c].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                      var bd_c_left = bd_c1 - 1;
                      if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                        if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_left]) == "object" && data[bd_r][bd_c_left].mc != null) {
                          var cell_left = data[bd_r][bd_c_left];
                          var mc = cfg["merge"][cell_left.mc.r + "_" + cell_left.mc.c];
                          if (mc.c + mc.cs - 1 == bd_c_left) {
                            borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                    if (bd_c == bd_c2) {
                      if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                        borderInfoCompute[bd_r + "_" + bd_c] = {};
                      }
                      borderInfoCompute[bd_r + "_" + bd_c].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                      var bd_c_right = bd_c2 + 1;
                      if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                        if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_right]) == "object" && data[bd_r][bd_c_right].mc != null) {
                          var cell_right = data[bd_r][bd_c_right];
                          var mc = cfg["merge"][cell_right.mc.r + "_" + cell_right.mc.c];
                          if (mc.c == bd_c_right) {
                            borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                              color: borderColor,
                              style: borderStyle
                            };
                          }
                        } else {
                          borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      }
                    }
                  }
                }
              } else if (borderType == "border-inside") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (bd_r == bd_r1 && bd_c == bd_c1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r2 && bd_c == bd_c1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r1 && bd_c == bd_c2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r2 && bd_c == bd_c2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.c == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.c + mc.cs - 1 == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.c == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.c + mc.cs - 1 == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_c == bd_c1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.r == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.r + mc.rs - 1 == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_c == bd_c2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.r == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.r + mc.rs - 1 == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.r == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.r + mc.rs - 1 == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                        if (mc.c == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.c + mc.cs - 1 == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  }
                }
              } else if (borderType == "border-horizontal") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (bd_r == bd_r1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_r == bd_r2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c];
                        if (mc.r == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].t = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.r + mc.rs - 1 == bd_r) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].b = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  }
                }
              } else if (borderType == "border-vertical") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (bd_c == bd_c1) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else if (bd_c == bd_c2) {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                        var cell = data[bd_r][bd_c];
                        var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c] || {};
                        if (mc.c == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].l = {
                            color: borderColor,
                            style: borderStyle
                          };
                        } else if (mc.c + mc.cs - 1 == bd_c) {
                          if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                            borderInfoCompute[bd_r + "_" + bd_c] = {};
                          }
                          borderInfoCompute[bd_r + "_" + bd_c].r = {
                            color: borderColor,
                            style: borderStyle
                          };
                        }
                      } else {
                        if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                          borderInfoCompute[bd_r + "_" + bd_c] = {};
                        }
                        borderInfoCompute[bd_r + "_" + bd_c].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                        borderInfoCompute[bd_r + "_" + bd_c].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  }
                }
              } else if (borderType == "border-none") {
                for (var bd_r = bd_r1; bd_r <= bd_r2; bd_r++) {
                  if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
                    continue;
                  }
                  for (var bd_c = bd_c1; bd_c <= bd_c2; bd_c++) {
                    if (borderInfoCompute[bd_r + "_" + bd_c] != null) {
                      delete borderInfoCompute[bd_r + "_" + bd_c];
                    }
                    if (bd_r == bd_r1) {
                      var bd_r_top = bd_r1 - 1;
                      if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                        delete borderInfoCompute[bd_r_top + "_" + bd_c].b;
                      }
                    }
                    if (bd_r == bd_r2) {
                      var bd_r_bottom = bd_r2 + 1;
                      if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                        delete borderInfoCompute[bd_r_bottom + "_" + bd_c].t;
                      }
                    }
                    if (bd_c == bd_c1) {
                      var bd_c_left = bd_c1 - 1;
                      if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                        delete borderInfoCompute[bd_r + "_" + bd_c_left].r;
                      }
                    }
                    if (bd_c == bd_c2) {
                      var bd_c_right = bd_c2 + 1;
                      if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                        delete borderInfoCompute[bd_r + "_" + bd_c_right].l;
                      }
                    }
                  }
                }
              }
            }
          } else if (rangeType == "cell") {
            var value = borderInfo[i].value;
            var bd_r = value.row_index, bd_c = value.col_index;
            if (bd_r < dataset_row_st || bd_r > dataset_row_ed || bd_c < dataset_col_st || bd_c > dataset_col_ed) {
              continue;
            }
            if (cfg["rowhidden"] != null && cfg["rowhidden"][bd_r] != null) {
              continue;
            }
            if (value.l != null || value.r != null || value.t != null || value.b != null) {
              if (borderInfoCompute[bd_r + "_" + bd_c] == null) {
                borderInfoCompute[bd_r + "_" + bd_c] = {};
              }
              if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c]) == "object" && data[bd_r][bd_c].mc != null) {
                var cell = data[bd_r][bd_c];
                var mc = cfg["merge"][cell.mc.r + "_" + cell.mc.c] || {};
                if (value.l != null && bd_c == mc.c) {
                  borderInfoCompute[bd_r + "_" + bd_c].l = {
                    color: value.l.color,
                    style: value.l.style
                  };
                  var bd_c_left = bd_c - 1;
                  if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_left]) == "object" && data[bd_r][bd_c_left].mc != null) {
                      var cell_left = data[bd_r][bd_c_left];
                      var mc_l = cfg["merge"][cell_left.mc.r + "_" + cell_left.mc.c];
                      if (mc_l.c + mc_l.cs - 1 == bd_c_left) {
                        borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                          color: value.l.color,
                          style: value.l.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                        color: value.l.color,
                        style: value.l.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].l = null;
                }
                if (value.r != null && bd_c == mc.c + mc.cs - 1) {
                  borderInfoCompute[bd_r + "_" + bd_c].r = {
                    color: value.r.color,
                    style: value.r.style
                  };
                  var bd_c_right = bd_c + 1;
                  if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_right]) == "object" && data[bd_r][bd_c_right].mc != null) {
                      var cell_right = data[bd_r][bd_c_right];
                      var mc_r = cfg["merge"][cell_right.mc.r + "_" + cell_right.mc.c];
                      if (mc_r.c == bd_c_right) {
                        borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                          color: value.r.color,
                          style: value.r.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                        color: value.r.color,
                        style: value.r.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].r = null;
                }
                if (value.t != null && bd_r == mc.r) {
                  borderInfoCompute[bd_r + "_" + bd_c].t = {
                    color: value.t.color,
                    style: value.t.style
                  };
                  var bd_r_top = bd_r - 1;
                  if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                    if (data[bd_r_top] != null && (0, method_1.getObjType)(data[bd_r_top][bd_c]) == "object" && data[bd_r_top][bd_c].mc != null) {
                      var cell_top = data[bd_r_top][bd_c];
                      var mc_t = cfg["merge"][cell_top.mc.r + "_" + cell_top.mc.c];
                      if (mc_t.r + mc_t.rs - 1 == bd_r_top) {
                        borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                          color: value.t.color,
                          style: value.t.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                        color: value.t.color,
                        style: value.t.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].t = null;
                }
                if (value.b != null && bd_r == mc.r + mc.rs - 1) {
                  borderInfoCompute[bd_r + "_" + bd_c].b = {
                    color: value.b.color,
                    style: value.b.style
                  };
                  var bd_r_bottom = bd_r + 1;
                  if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                    if (data[bd_r_bottom] != null && (0, method_1.getObjType)(data[bd_r_bottom][bd_c]) == "object" && data[bd_r_bottom][bd_c].mc != null) {
                      var cell_bottom = data[bd_r_bottom][bd_c];
                      var mc_b = cfg["merge"][cell_bottom.mc.r + "_" + cell_bottom.mc.c];
                      if (mc_b.r == bd_r_bottom) {
                        borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                          color: value.b.color,
                          style: value.b.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                        color: value.b.color,
                        style: value.b.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].b = null;
                }
              } else {
                if (value.l != null) {
                  borderInfoCompute[bd_r + "_" + bd_c].l = {
                    color: value.l.color,
                    style: value.l.style
                  };
                  var bd_c_left = bd_c - 1;
                  if (bd_c_left >= 0 && borderInfoCompute[bd_r + "_" + bd_c_left]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_left]) == "object" && data[bd_r][bd_c_left].mc != null) {
                      var cell_left = data[bd_r][bd_c_left];
                      var mc_l = cfg["merge"][cell_left.mc.r + "_" + cell_left.mc.c];
                      if (mc_l.c + mc_l.cs - 1 == bd_c_left) {
                        borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                          color: value.l.color,
                          style: value.l.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_left].r = {
                        color: value.l.color,
                        style: value.l.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].l = null;
                }
                if (value.r != null) {
                  borderInfoCompute[bd_r + "_" + bd_c].r = {
                    color: value.r.color,
                    style: value.r.style
                  };
                  var bd_c_right = bd_c + 1;
                  if (bd_c_right < data[0].length && borderInfoCompute[bd_r + "_" + bd_c_right]) {
                    if (data[bd_r] != null && (0, method_1.getObjType)(data[bd_r][bd_c_right]) == "object" && data[bd_r][bd_c_right].mc != null) {
                      var cell_right = data[bd_r][bd_c_right];
                      var mc_r = cfg["merge"][cell_right.mc.r + "_" + cell_right.mc.c];
                      if (mc_r.c == bd_c_right) {
                        borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                          color: value.r.color,
                          style: value.r.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r + "_" + bd_c_right].l = {
                        color: value.r.color,
                        style: value.r.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].r = null;
                }
                if (value.t != null) {
                  borderInfoCompute[bd_r + "_" + bd_c].t = {
                    color: value.t.color,
                    style: value.t.style
                  };
                  var bd_r_top = bd_r - 1;
                  if (bd_r_top >= 0 && borderInfoCompute[bd_r_top + "_" + bd_c]) {
                    if (data[bd_r_top] != null && (0, method_1.getObjType)(data[bd_r_top][bd_c]) == "object" && data[bd_r_top][bd_c].mc != null) {
                      var cell_top = data[bd_r_top][bd_c];
                      var mc_t = cfg["merge"][cell_top.mc.r + "_" + cell_top.mc.c];
                      if (mc_t.r + mc_t.rs - 1 == bd_r_top) {
                        borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                          color: value.t.color,
                          style: value.t.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_top + "_" + bd_c].b = {
                        color: value.t.color,
                        style: value.t.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].t = null;
                }
                if (value.b != null) {
                  borderInfoCompute[bd_r + "_" + bd_c].b = {
                    color: value.b.color,
                    style: value.b.style
                  };
                  var bd_r_bottom = bd_r + 1;
                  if (bd_r_bottom < data.length && borderInfoCompute[bd_r_bottom + "_" + bd_c]) {
                    if (data[bd_r_bottom] != null && (0, method_1.getObjType)(data[bd_r_bottom][bd_c]) == "object" && data[bd_r_bottom][bd_c].mc != null) {
                      var cell_bottom = data[bd_r_bottom][bd_c];
                      var mc_b = cfg["merge"][cell_bottom.mc.r + "_" + cell_bottom.mc.c];
                      if (mc_b.r == bd_r_bottom) {
                        borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                          color: value.b.color,
                          style: value.b.style
                        };
                      }
                    } else {
                      borderInfoCompute[bd_r_bottom + "_" + bd_c].t = {
                        color: value.b.color,
                        style: value.b.style
                      };
                    }
                  }
                } else {
                  borderInfoCompute[bd_r + "_" + bd_c].b = null;
                }
              }
            } else {
              delete borderInfoCompute[bd_r + "_" + bd_c];
            }
          }
        }
      }
      return borderInfoCompute;
    };
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelValidation.js
var require_ExcelValidation = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelValidation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setDataValidations = void 0;
    var constant_1 = require_constant();
    function rowColToCell(rowColumn) {
      var _a = rowColumn.split("_").map(Number), row = _a[0], col = _a[1];
      function columnToLetters(colIndex) {
        var letters = "";
        while (colIndex >= 0) {
          letters = String.fromCharCode(colIndex % 26 + 65) + letters;
          colIndex = Math.floor(colIndex / 26) - 1;
        }
        return letters;
      }
      var columnLetters = columnToLetters(col);
      var rowNumber = row + 1;
      return "".concat(columnLetters).concat(rowNumber);
    }
    function getExcelValidation(cellVerification) {
      var excelValidation = {
        type: constant_1.DATA_VERIFICATION_REV_MAP[cellVerification.type],
        showInputMessage: !!cellVerification.hintShow,
        showErrorMessage: !!cellVerification.prohibitInput,
        prompt: cellVerification.hintValue
      };
      switch (cellVerification.type) {
        case "dropdown":
          excelValidation.formulae = ['"' + cellVerification.value1 + '"'];
          break;
        case "number":
        case "number_integer":
        case "number_decimal":
          excelValidation.operator = constant_1.OPERATOR_MAP[cellVerification.type2];
          excelValidation.formulae = [
            parseFloat(cellVerification.value1),
            parseFloat(cellVerification.value2)
          ];
          break;
        case "text_length":
          excelValidation.operator = constant_1.OPERATOR_MAP[cellVerification.type2];
          excelValidation.formulae = [
            parseInt(cellVerification.value1),
            parseInt(cellVerification.value2)
          ];
          if (!excelValidation.formulae[1])
            excelValidation.formulae.pop();
          break;
        case "date":
          excelValidation.operator = constant_1.OPERATOR_MAP[cellVerification.type2];
          excelValidation.formulae = [
            new Date(cellVerification.value1),
            new Date(cellVerification.value2)
          ];
          break;
        default:
          return {};
      }
      return excelValidation;
    }
    function setDataValidations(table, worksheet) {
      for (var key in table.dataVerification) {
        var cell = rowColToCell(key);
        worksheet.getCell(cell).dataValidation = getExcelValidation(table.dataVerification[key]);
      }
    }
    exports.setDataValidations = setDataValidations;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelConfig.js
var require_ExcelConfig = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setHiddenRowCol = void 0;
    function setHiddenRowCol(table, worksheet) {
      var _a, _b;
      for (var row in (_a = table.config) === null || _a === void 0 ? void 0 : _a.rowhidden) {
        worksheet.getRow(parseInt(row) + 1).hidden = true;
      }
      for (var col in (_b = table.config) === null || _b === void 0 ? void 0 : _b.colhidden) {
        worksheet.getColumn(parseInt(col) + 1).hidden = true;
      }
    }
    exports.setHiddenRowCol = setHiddenRowCol;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelFile.js
var require_ExcelFile = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToExcel/ExcelFile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exportSheetExcel = void 0;
    var exceljs_1 = __importDefault(require_exceljs_min());
    var fileSaver = __importStar(require_FileSaver_min());
    var ExcelStyle_1 = require_ExcelStyle();
    var method_1 = require_method();
    var ExcelImage_1 = require_ExcelImage();
    var ExcelBorder_1 = require_ExcelBorder();
    var ExcelValidation_1 = require_ExcelValidation();
    var ExcelConfig_1 = require_ExcelConfig();
    function exportSheetExcel(luckysheetRef) {
      return __awaiter(this, void 0, void 0, function() {
        var luckysheet, workbook, buffer, fileData;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              luckysheet = luckysheetRef.getAllSheets();
              workbook = new exceljs_1.default.Workbook();
              luckysheet.every(function(table) {
                var _a2, _b;
                if (((_a2 = table === null || table === void 0 ? void 0 : table.data) === null || _a2 === void 0 ? void 0 : _a2.length) === 0)
                  return true;
                var worksheet = workbook.addWorksheet(table.name);
                (0, ExcelStyle_1.setStyleAndValue)(luckysheetRef, table, worksheet);
                (0, method_1.setMerge)((_b = table === null || table === void 0 ? void 0 : table.config) === null || _b === void 0 ? void 0 : _b.merge, worksheet);
                (0, ExcelBorder_1.setBorder)(table, worksheet);
                (0, ExcelImage_1.setImages)(table, worksheet, workbook);
                (0, ExcelValidation_1.setDataValidations)(table, worksheet);
                (0, ExcelConfig_1.setHiddenRowCol)(table, worksheet);
                return true;
              });
              return [4, workbook.xlsx.writeBuffer()];
            case 1:
              buffer = _a.sent();
              fileData = new Blob([buffer]);
              fileSaver.saveAs(fileData, "".concat(luckysheetRef.getSheet().name, ".xlsx"));
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.exportSheetExcel = exportSheetExcel;
  }
});

// node_modules/@corbe30/fortune-excel/dist/common/Transform.js
var require_Transform = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/common/Transform.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformFortuneToExcel = exports.transformExcelToFortune = void 0;
    var FortuneFile_1 = require_FortuneFile();
    var HandleZip_1 = require_HandleZip();
    var ExcelFile_1 = require_ExcelFile();
    var transformExcelToFortune = function(e, setSheets, setKey, sheetRef) {
      return __awaiter(void 0, void 0, void 0, function() {
        var excelFile, files, fortuneFile, lsh, config, _i, _a, sheet;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, e.target.files[0].arrayBuffer()];
            case 1:
              excelFile = _b.sent();
              return [4, new HandleZip_1.HandleZip(excelFile).unzipFile()];
            case 2:
              files = _b.sent();
              fortuneFile = new FortuneFile_1.FortuneFile(files, excelFile.name);
              fortuneFile.Parse();
              lsh = fortuneFile.serialize();
              config = lsh.sheets[0].config;
              for (_i = 0, _a = lsh.sheets; _i < _a.length; _i++) {
                sheet = _a[_i];
                delete sheet.config;
              }
              setSheets(lsh.sheets);
              setKey(function(k) {
                return k + 1;
              });
              setTimeout(function() {
                var _a2, _b2;
                (_a2 = sheetRef.current) === null || _a2 === void 0 ? void 0 : _a2.setColumnWidth((config === null || config === void 0 ? void 0 : config.columnlen) || {});
                (_b2 = sheetRef.current) === null || _b2 === void 0 ? void 0 : _b2.setRowHeight((config === null || config === void 0 ? void 0 : config.rowlen) || {});
              }, 1);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.transformExcelToFortune = transformExcelToFortune;
    var transformFortuneToExcel = function(luckysheetRef) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, ExcelFile_1.exportSheetExcel)(luckysheetRef)];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.transformFortuneToExcel = transformFortuneToExcel;
  }
});

// node_modules/@corbe30/fortune-excel/dist/common/ToolbarItem.js
var require_ToolbarItem = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/common/ToolbarItem.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importToolBarItem = exports.exportToolBarItem = void 0;
    var ExportIcon_1 = __importDefault(require_ExportIcon());
    var ImportIcon_1 = __importDefault(require_ImportIcon());
    var Transform_1 = require_Transform();
    var exportToolBarItem = function(sheetRef) {
      return {
        key: "export",
        tooltip: "Export .xlsx",
        icon: (0, ExportIcon_1.default)(),
        onClick: function(e) {
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, (0, Transform_1.transformFortuneToExcel)(sheetRef.current)];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      };
    };
    exports.exportToolBarItem = exportToolBarItem;
    var importToolBarItem = function() {
      return {
        key: "import",
        tooltip: "Import .xlsx",
        icon: (0, ImportIcon_1.default)(),
        onClick: function(e) {
          var _a;
          (_a = document.getElementById("ImportHelper")) === null || _a === void 0 ? void 0 : _a.click();
        }
      };
    };
    exports.importToolBarItem = importToolBarItem;
  }
});

// node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/ImportHelper.js
var require_ImportHelper = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/ToFortuneSheet/ImportHelper.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImportHelper = void 0;
    var react_1 = __importDefault(require_react());
    var Transform_1 = require_Transform();
    var ImportHelper = function(props) {
      var setSheets = props.setSheets, setKey = props.setKey, sheetRef = props.sheetRef;
      return react_1.default.createElement("input", { type: "file", id: "ImportHelper", accept: ".xlsx", onChange: function(e) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, (0, Transform_1.transformExcelToFortune)(e, setSheets, setKey, sheetRef)];
              case 1:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, hidden: true });
    };
    exports.ImportHelper = ImportHelper;
  }
});

// node_modules/@corbe30/fortune-excel/dist/main.js
var require_main = __commonJS({
  "node_modules/@corbe30/fortune-excel/dist/main.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ToolbarItem(), exports);
    __exportStar(require_ImportHelper(), exports);
  }
});
export default require_main();
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=@corbe30_fortune-excel.js.map
